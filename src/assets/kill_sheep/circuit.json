{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":15615795875467935312,"abi":{"parameters":[{"name":"wolf_value","type":{"kind":"field"},"visibility":"private"},{"name":"wolf_index","type":{"kind":"field"},"visibility":"private"},{"name":"wolf_salt","type":{"kind":"field"},"visibility":"private"},{"name":"sheep_positions","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"sheep_alive","type":{"kind":"array","length":16,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"wolf_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"sheep_to_kill_index","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"// Circuit for validating wolf kills a sheep\n// Verifies:\n// 1. The wolf identity is valid (matches the commitment)\n// 2. The sheep to kill is adjacent to the wolf\n// 3. The sheep to kill is alive\n\nuse std::hash::poseidon;\n\nfn main(\n    wolf_value: Field, // 5\n    wolf_index: Field, // 4\n    wolf_salt: Field, // 0\n    sheep_positions: [Field; 16],\n    sheep_alive: [bool; 16],\n\n    wolf_commitment: pub Field,\n    sheep_to_kill_index: pub Field, // 0\n) {\n    // Verify that the wolf commitment is valid\n    assert(poseidon::bn254::hash_2([wolf_value, wolf_salt]) == wolf_commitment);\n\n    // Verify that the wolf is in the correct position\n    assert(sheep_positions[wolf_index as u64] == wolf_value);\n\n    // Verify that the sheep to kill is alive\n    assert(sheep_alive[sheep_to_kill_index as u64] == true);\n\n    // Calculate row and column for wolf and sheep\n    let wolf_position_as_u64 = wolf_index as u64;\n    let wolf_row = wolf_position_as_u64 / 4;\n    let wolf_col = wolf_position_as_u64 % 4;\n    \n    let sheep_position_as_u64 = sheep_to_kill_index as u64;\n    let sheep_row = sheep_position_as_u64 / 4;\n    let sheep_col = sheep_position_as_u64 % 4;\n    \n    // Calculate absolute differences for adjacency check\n    let row_diff: u64 = if wolf_row > sheep_row { \n        wolf_row - sheep_row \n    } else { \n        sheep_row - wolf_row \n    };\n    \n    let col_diff: u64 = if wolf_col > sheep_col { \n        wolf_col - sheep_col \n    } else { \n        sheep_col - wolf_col \n    };\n    \n    // Check if positions are adjacent (horizontally, vertically, or diagonally)\n    // Allow movement in 8 directions (horizontal, vertical, and diagonal)\n    // Maximum row and column difference should be 1, and they can't both be 0\n    assert(row_diff <= 1);\n    assert(col_diff <= 1);\n    assert(row_diff + col_diff > 0); // Ensure they're not the same position\n} \n","path":"/Users/damianalejandropinones/Documents/temp/noir/scaffold-garaga/circuit/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}