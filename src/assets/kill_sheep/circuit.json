{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":2315664091742313256,"abi":{"parameters":[{"name":"wolf_value","type":{"kind":"field"},"visibility":"private"},{"name":"wolf_index","type":{"kind":"field"},"visibility":"private"},{"name":"wolf_salt","type":{"kind":"field"},"visibility":"private"},{"name":"sheep_positions","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"sheep_alive","type":{"kind":"array","length":16,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"wolf_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"sheep_to_kill_index","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"// Circuit for validating wolf kills a sheep\n// Verifies:\n// 1. The wolf identity is valid (matches the commitment)\n// 2. The sheep to kill is adjacent to the wolf\n// 3. The sheep to kill is alive\n\nuse std::hash::poseidon;\n\nfn main(\n    wolf_value: Field, // 5\n    wolf_index: Field, // 4\n    wolf_salt: Field, // 0\n    sheep_positions: [Field; 16],\n    sheep_alive: [bool; 16],\n\n    wolf_commitment: pub Field,\n    sheep_to_kill_index: pub Field, // 0\n) {\n    // Verify that the wolf commitment is valid\n    assert(poseidon::bn254::hash_2([wolf_value, wolf_salt]) == wolf_commitment);\n\n    // // Verify that the wolf is in the correct position\n    assert(sheep_positions[wolf_index as u64] == wolf_value);\n\n    // // Verify that the sheep to kill is alive\n    assert(sheep_alive[sheep_to_kill_index as u64] == true);\n\n    // // Calculate row and column for wolf and sheep\n    let wolf_position_as_u64 = wolf_index as u64;\n    let wolf_row = wolf_position_as_u64 / 4;\n    let wolf_col = wolf_position_as_u64 % 4;\n    \n    let sheep_position_as_u64 = sheep_to_kill_index as u64;\n    let sheep_row = sheep_position_as_u64 / 4;\n    let sheep_col = sheep_position_as_u64 % 4;\n    \n    // Calculate absolute differences for adjacency check\n    let row_diff: u64 = if wolf_row > sheep_row { \n        wolf_row - sheep_row \n    } else { \n        sheep_row - wolf_row \n    };\n    \n    let col_diff: u64 = if wolf_col > sheep_col { \n        wolf_col - sheep_col \n    } else { \n        sheep_col - wolf_col \n    };\n    \n    // // Check if positions are adjacent (horizontally, vertically, or diagonally)\n    // // Allow movement in 8 directions (horizontal, vertical, and diagonal)\n    // // Maximum row and column difference should be 1, and they can't both be 0\n    // assert(row_diff <= 1);\n    // assert(col_diff <= 1);\n    // assert(row_diff + col_diff > 0); // Ensure they're not the same position\n} \n","path":"/Users/damianalejandropinones/Documents/temp/noir/scaffold-garaga/circuit/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}