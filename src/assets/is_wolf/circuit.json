{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":18302866125379424031,"abi":{"parameters":[{"name":"wolf_value","type":{"kind":"field"},"visibility":"private"},{"name":"wolf_index","type":{"kind":"field"},"visibility":"private"},{"name":"wolf_salt","type":{"kind":"field"},"visibility":"private"},{"name":"sheep_positions","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"sheep_alive","type":{"kind":"array","length":16,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"wolf_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"sheep_to_check_index","type":{"kind":"field"},"visibility":"public"},{"name":"is_wolf_result","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9W9B6B2S1aW+d3upqFvQwOdgAYaaHKusKt2bXJGEBpopclo7QowqKiomFFRxzzmrKNiTqOOOSvqmMecc86CgGMe51mn/6t7nfsL46y9ne+e5nDv/cN3du2qWut9n1Xhmdtbvr7lJbfbd3nmLf/+4ie/9g63//rf/Pbtrfh+Kd9vzffb8P0yvp/l++V8vy3fb8f3K/h++yd/9x35fuWTz3jmyefIP1/15J/HX3v1U37tNU/5tdc+5dfe6Sm/9s5P+bV3ecqvve4pv/auT/m1d3vKr737U37t9U/5tfd4yq+951N+7b2e8mtvePTfz/XJq568s9c8eSfv9KTN7/KkTe/65Jnf/ckzvceTn/leTz7zua8nXX77uCf/dLYv/9znvujx5/oRSqlL3scSNl/26NruRuhxlrhuu3cze1+36rzrfh+1hz7nKD7U3l0rx8+KLi/LWMPw0VcXtr0kt6Q9F198KqmHEuMoS+Fjt9VtfonDz7TF+eQh3+/wWX4svvO/1Te/p3Vuwafe+95CHGFt61JLa8m1EUvzMbqt8jRzn6HkrY3dHV7l89t8wrs8q83vr55r+mVJIaYZ/FJa2kpOZfV5m7yE1ktZd1f60p0rufSZ8pbnnIvbUh4lL1eMG+mT93vK51rb/QHnPaO7ot0vejJuHo8d7/c58uZm97QmtjhSXNzuK61zfg3Zl5HcyD7TPblv3c04Vh9838ZYR33Rie/wA9V8SevotTeGhO8puNJm9HP1s8bJoGrdrXXZQovO5cJAK4lHd54502UA3S6cL2e2+YOOz8UcmJE/O0pt28YfDMSpVHjntbh9I5StoazR7WvdY26DT52xbG60ucaZrhg30icfeMF8+eDbtfPF59EXz9Pt+9Zcy7kO77clLFOC7t626BcG1+x7H6Om1HPLS1pib8vm4niIYx9wQbu/9Jlr2x32ze17JfQ2GTob2W4da2/M8hKG63N1ue55IdPsYVn3dSMZxn1dRsxrzF3G4wdf0O7vdHK7n/t68cnP+SEnzp0T+9of319wo+eRiH7b2JEJaV23QjyYaw9jW1rcEvG51m1ZSwlhra0mBn3MTIXsY33auHG2Ly/v7UMuGDcfervvvCrP96EXtPvDbi+M+fLhx+ec29azI5LEUuI+kXZrc8MFIrFb1zGW4uuKHo9hXfuCHFx3v5LS9+Ar4/Q4X8Ky1dGQgX3dQpE/uoSWctyGQ8f7bY/rWLJHRo+8u9q3tK1oktkJawV9oObLgrzJpZU621rizHtlQvjSmQyrW52LAcW55G1PeIU8tpxLcCH61lza47hi3Mh7+/ALxo273fd8kQ91F7Tb314Y8yWo52wthyXP3cdZZ1nb5jLSGjHLJCJ4r5Ksid77yDnueNmCZeUfsYW67/04X3CzY2duJHTyCKKG84x7DmOJMe1bQhKsQURjaPhjjGXr28ZQX4IkkBDUfEEFZe+20BsSwSff+cGVmepiY07sHv/qYkprmiPG2HOYvS491ITI2q/RofLewgXjJt7ue77I88UL2r1c3G6Gz77OBXtZ3VjatoedyF9nQoZUwv627GNtkJgelrgW5Gnn4dMW9lo82Ea0xIdd0O7vfLH+tvoOyQn+gnbXO/cdMreXC9q9X+Q7XnLyc6bz5qM/cYz7E8eNP/YFScgz6OvY66i1hFLjmjs5sM6lkuxa2Vfo51r7gmkJWxlzJf/Jr5UUcn/aGHS2Ly99kC4Yg/l23zlGni9f0O719sKYe+X4nDiYHInXbk2dvDVbKy7jnHsv0NGwhMBoDVWsQ8UfZEoNwGv5xaVA4dTcM/qheqIfUnNvDStBdw9NEpKL6E1kWyyD2gTwtAcXI6Q+oE9jCnvzCS1YqI/0ubV9LVeMQfnQcsEY3G73Pffk+bYL2v0RtxfG3PvIw2cFnMS2z7osjNtWS2fsYVzWDdHol0mNbmP+7G4vBWnhA/IRp8MECiGkXPTcM3qreqK3UnMvLqNRvqhMeep+YVD522loqH4B3cH1pIAReURU1NrzzudtIzKrEw2K4YoxKH3wkReMwY+63ffck+f7qAva/dEXt9vqrUTjrBe0u925t5L88hEXtLvfubeSuf3RF7R7vEC81cecNx/9iWPcnzhu/LEvfNpTkDI+r2t4VOksOTTk3lz5v+zq7h2RILkaI+GiSbqaM0s5GRkaLtF30gcfc8EY/NjbfecYeb6PvaDdH3d7Ycy9j7+d563aid6qn+itVBzsrczac9/Gssc00+hbjRSbMmFZVncNN0oVrZkK0jT0lTiwjNFm5hdnvmIMSh98/AVj8BNu9z335Pk+4YJ2f+LthTH3Pul2nrdqJ3qrfqK3Unlv5zfTnC145nmrGcW0usR0jHNPeR11GczlMvl4P0fb1uJS8qUuzO++tSvGoPTBJ10wBj/5dt9zT57vky9o96dc3G6rt3pOa57d7nnn3kryyyde0O4vu3NvJXP7Uy5o95e/QLzVp543H/2JY9yfOG78l6t8BRdHBO5r8K32ObYxyZ47VZTZIlOEKlaVdJXWshEg/Np4caW7vPWR0va0MehsX1764FMvGIPf7nbfOUae79td0O5Pu/N2S19/2gXt/vTb0RPFZYk4sZmXiWz0eKJ1dNkjMBviKueCnduzI11Uv4ZFTJXD4bSBmRnhdvh6q0fPac2xn35im7/9sc1zbjnhG0Pal7mO6XIpexfr5ubEnS591rHyFGTDMqdHJ6e2xFpzSzH1Y/wKnqeiiNbEjnYMr1t3YH/Y+BG9SwLJTrJn8R0z2vzg96gNdJSy20eax/jlw1owoHhisbbBDQp0DnU7ENu0uA23xz3S7DKab7tLvF4+yJUNlT56VPFr2+u28lXWgDRHS1NiiOQ3l9e0wIGkPsGPawhmPq83LG8Uyb3vEUFwCRuSPvj2F4znz7jd9zyW5/uMC9r9mXfebunrz7yg3W88zuVQJ1Z3nz31dYCaOjaWrNyYjRHexADf68iI2dYdM9gtO4HH4xUr88D/l/2F8vXSx+33g+k895wo2hH/fJRV9zVIbNobwYyI6WLy3S1u6TFTyc8wnnWNPve4pGP8ssbCN574/j7r+Fx9R/iOFfaWN+K+XxJef8ROzbJg7kFVNKwsHdcgG7KWQnUSQexTaAVEpmIhyijWFZ1E9Npq3kADg2gH96tlX3xKFEFdnnWVbZuxtc3vfY+18SdD35PSchXx5UuXPQ4bPeoyBK2MsTUx8anNjVBWSoIfjsmfKS1udMPA0uBWSlW6ejbe06Rdcc1N/lKs/N0JFAlzOOD5yGHHEewZesLj+GVd+bMkia3Mbb1ibkgffNYFc+Ozb/cdE+T5PvuCdn/Onbdb+vpzLmj3m45zeZl7j+usTMw8FubCWmpwfYsNEeAa0mJl0K/7AiyPIVIwggXCAwUAMHVuh6+3fvScuGXnERPMNYfVIaRuCeOMzEh7XIionom3ArtrR0y0uKYBdFxq2nzvRJZjLLTG1WMstMbVN53YF9/h2Eay0rasrpKSKEWQkHiDIBTiKCEr7tTuSgFgpiQ+M/FTfeiEppFGdMkpjemp8EXea+z7VhqchkBGmSNBYOGsG4WPhNqUesogWBMc3ZRt8JBOhwJNOq4uqUJ5qvxJ1LzvEzxaG5oSfcvPhnzAcHcXQKyOasw2iJxUcrZSM7Fba8xQpvNbqkN+h2xKLu5tknPDNooLFFuQz6QAv06yxaSrUchDwGzi/y5Z2yl98B0umGff8Xbf8UWe7zte0O7PvfN2S19/7gXtfvPtWGevW9iITUxZqbf3hRr7JuaYIEvsKRI+m9QcJp8ycMiz1nXIChzmWVB71N/mcfvLGlOK+7bEuYW5rz7j+mRpGHUPVBHetCLRZBWZbwksy8ejsgYiZ99q90pjGmP0Ma5aY7TKS8YY/eYT+/Xz1Lv3a8KM19L4nRADYanQDZSWVnxDwVovlRQKJeajqWjT0LCPHXHIh+ZdxWhXlw4tTBkq4sq+7Rl8QlbNk8ajdClyMWZWeIqUyfD+BGdGEz0a0uZUjKY8NnwFOwqH4WVvM/naSphr9ZmQvW3E77jFOkgikUejvr6HTY7fyJXqmdK+bYNekG8YVH4CGPiovmzr0hnN25xxo7hX8kLrBwlkbZMuYqTVSu90dwnHlD74vAvm7Off7jtWyfN9/gXt/oI7b7f09Rdc0O4vvB2959oHOihg+iuDNwSPwh27lHMmnq7EgU8MoyR+IsFzaQGux8TLGFRq5LfD18sePScyB1rYHR+1rVMIGvVoN/eCLEPWEZZlAQkwz/d13bcMBRzUyiAO2zL9ULzVGu+V9jXG+2OMtsZ7lS+N8f4LTxwjX3RsIzQjCAMNoW87nUPck8Asyxxmqr1vQf4ArIHASnCWGtC2L43QPeq+rKpuRR1o64VWrtPnLTqJyUTtieBdR1plzBC8xyDHzIUwu+55wjMkSkPao+K+cpYVCn7GmKIH5dIgKkwMrgmkHZES5fQTQU06SS7vNTqYsCSZlQ7dF6XJIVzUNVd4/tqp7saW6KkQyxLgHIxhmJgvJbfopdQ5W3DkNyYL/BoOfMkeeOmDL7pg/n/x7b7jnjzfF1/Q7i+583ZLX3/JBe3+0uMzEkooXIUqCwcLdZZSo0/87bYgi3CehK48pdIziD+ocHQStZ5lxYOmFtbb4evZR88ZIjIoLnwqWHn2ngAqYZmb36jAlLp3zw93gbiaowtQFcJHpqwip831WIKqrxlzh9LkxtyhNLkxdxzjvTV3HOO9NXd86Ynj7Tsdn4uRRo2PcMnryXFOWrfzK1mqDsM7VxPJpDUelC6S/sAu5g2ELpU1HKHiOctMKwXBSBP5/xuWkp6VomDta6UzqPzhSqj77Sv9GSedvr9FpDdqtCp3EMRbrBPmQnbpgQrHVjrvf5HyHxaCCiJeImyd6uRsD1B/38cD+97yyCp3tLL1yhBPsB5klFszo1eQzT5KpiAsywYHuikDxuXXKKFua179voRWr9mzJH3wnS6IJd/5dt8xVJ7vO1/Q7nrn7Za+rhe0e78pf+2ItsyEAq301NklYhLY/VLRYlBQyuMNojr5r5Idbr8l0kyTfRMjKa/w8sftX8ViL8mvUu/qGRS7N79QGiPs14QPX4KsJYpy1qKLWysDJSaoVbZn+KhyhzEPqTqpMQ8pr2DMQ8orGPPQMXdY89Axd1jz0H7i2G3HNlLPIcXwLoj8fmVgiGeI2IPuXZey6EL8xzIsg3RAC3beJdBKKkEkgl17mOmFUPWFQM/gq7LxFJ5POXQloaQN/8LvUMtN+77GIfszRuXlL3nhP3fFrJprkzTIi4hYHsfQHosc7OAYJdQcxoY5B5BSm40r9d+KG6eOQeGD0sHYFbPyO39so54xOk8dqQQXPsxRNpZ523jq1cU1JFlRjvGCUvU0QvMh97lBam+38+OS9EG7XbCn8Hbf8Vier1/Q7nHn7Za+Hhe0ex6fsYZcxiyrW2MeD0c8Uq3bB4QCPYj6I5dskhqW1lxsI0W4QpRNT3NSZVtuh6+3ffScnoLhTr1xUpUg7MId0JNttoXJ53coSOh1lWDvw45yLdQcZR2I762g92pVzMqY01QeMua0Yx6y5jTlYYw5TXkYY05TPteY0455yJrT5onz4MvU+yq73/ukx8WSwLZKiTVsSwpy+Kn3fSzrwrTAwZAKapiJj9mpZ+QcSE+6DtMptwQKdH3J1J4xR2k2xlxKssZooXzicm674DCPzhNs3AZ/LsuQbLtejzkkrcSHk8sZnZM55TvT1XVqNhTPpW08BhXyNiGEvNOV17HIvtw9r0PVYTbxbru0Zo8MZYpBqS8U+lfKTJ2/SJOoM9GplUlOF7a+e+pRDHDJp3I03OkxTvrgy24X7Gm43Xdsl+f78gva/T/debulr/+nC9r9Fce5THLif4Q4SpxLBnUHypUOgerRk0sJ8DhiYWmbG6SIvCHZiJBelpmTStR68rd79JwiLwsYr9dMlXUhYvheS8wTfYk/e1gJTS6F71MxneSpDWQu62YodkJPVB3Gmh8VlzPmR5XTjPnxmNOs+VF5K2N+VN7KmB+POc2aH+ftvPz4FSfOqe9y7EfqS7Ove+PZtzSpDZXcKUg12T9Px/Dzt7BSyUrA8L1EkiUUcWcqUtqiY1V+3Hhe+AfpRV5DT1uKsENsFpiS6hc6s/KGGKF9oy5EnSgn3qtM0bTCSlR+JNNG37Bxsui2RKYGc8WntizLvuA+4Yj8sNCa5+NGowhL/uU/kbohhPWYH2X9bwwrLZu8r75u8HzmQZWzAhmvRBLZolITVat9UOnNW25VNEFzDJL1kngpffBdbufHy+96u+88Ic/3XS9o93e783ZLX3+3C9r9lce5vI4ipyoTOomwtWyNsJbJh/sKc4l1eTgIjMkHiSRzLgRCTxGXUnBYqESr/PiKx+1P0QkIAfe0wQeXvfGxSyc0bVFWQuQk4RKpSUmbFOoCM15K1oOswj/0fgVbrlXrFIy5VrFHY65V+dGYa9X6E2OuVZ7PmGuV5zPmWsUrjLlW6URjrv3KE+fndz8+18JPl7JeeRg9rtDhkFD+szq/zeacDIx95lYYrXkv/A6P5LIfq19rU7mWhIxz9UxmKnIMhULhbwbKhnN1w9eU5EQc0i5kVXbq7eWh+uDCZOYuaVW5Nq45ViJBcD7MOvOkYOgCv0C42MvmiBNoAzcSIWULcrTNWGkmWRXnWXfFV2dPCHAsNR6Zv1pSWt0smfQ/qBPK/U/MJYYeL3KljXsaNHzJfs3k33nJ+RnSB9/9dn7s/R63+8458nzf44J2f887b7f09fe8oN1fdXxGv4iMHFSrtzmII1Q3KLz33IiUqcBW160R76ma8ynkuiCJBSNKwIS+brfD19s/es7ABKFgEnwCW5HC0j5XHtDLPWpUKza3L6USRutOGTHM2WRRYnNba2kdhF7FV415W++HseVttUbEmLcVXzXmbZVrjXn7mGuteVt5UWPeVl7UmLe/4nZe3v7K23l5+6tOnOvfS42vNqIs5Q2OgbYymXyP6/5ww0kgCiwbiDby5DjmbXeyRJIcXDO9E7yjoKLW3zc504o3HKmu5rnNujOoPVOFyqRza8WFLo7pxKyXnakpM0uZUuDlyPj+Mn2OCL/HC09lp9K5rQ9hYF/QBYSmKNq/BSz0w14w3qsMfjm1kRkBI55qfY5Lssl5o+w7ed+ynd+PmR1jCD+calsZRnmjRLtsIO7ORzOMpehb18y0vWRtp/TB97qdH8e/9+2+85c83/e+oN3f587bLX39fS5o91ffjh65ubr4uTTY1aCQgkxeukxwucZrkhlJIOTIECmWTu9KH9XvO1RJ4lytt8PXOzx6Ti+HAzCt3SbcbIcqLcxjMBKTfmNyy3n5VGA7D7zKyR1Uf8jfLsvmy0aAU+tzjBpAMWSjBtD7rWwaQK3PMWoAxZCNGkDlbaMGOOZtqwZQHtmoAZRHNmqAY962aoCvup2nAb76xLjxfY/9GKRFzDH6nVwc0PyV2nFjiMe8yimxzFCetfMkHsdbyabY/AoSj67GVa/RDb3JNd0bk1y2zdU2mN3j4UJx/kaMclfakDWDsjcDDN3ito24O0+F2jWlARiVc1v7bDtv34sBgfXJKTxyGcAYlLlDYVJ7EjdV4twGU3/b5ailWIH4ipPT84wAPP7ueENV9luHvQPy86DWRlBoqwOvQ+wpLseF14H68PCEsNRRLrmzTfrg+97Ozwnf73bfuVCe7/td0O7vf+ftlr7+/he0+wfcjoxKtuYS/AszzO/Uf+IaIv8RAFBI97lMGc8BSewclTACT9s8hWcmZSgPIfm/fL3j4/aPlVBFDN/XKkFwIwuB2km4kZ8iIT6kpfGgA1o/iWWrwLZODqbM5qauIxv1hFobZdQTipMb9YTez2fTE2ptlFFPKE5u1BNKAxj1xFEDWPWE8u5GPaG8u1FPaLZm0xNffTtPT/yAE2PQDzz2I9N/y7xXL/WAMH2hFF7WxGtemCLCDpKEobaGSkcKW5QDsifKgZ+3qnNOvcwIZghVPdn0v9WV1C6HDFJC721r1BR26vyFv5r5cbwuB5yXdA6lcDGotdY8gVzixXtNO9OYn4tJiiVScq81jGUkxnmmfN86v7MypWRBjqz+3mEMSZ+NRTWibtQulkQFIA6pZDDdNs9bWlc5JY1PkNNq5JAgpNO6EjSanLW/yMSQzzg7v0gf/MDb+fnlB93uO6/K8/2gC9r9g++83dLXP/iCdn/NcS6nidwmnJexBWLQuhM8ot/JtXP20FdZyinHwm2U6QhUzDzHfwEYRvA55dvh65WPnpPA1J3vOfUqtb0tMXmJihL1kBK9zPqw4GZ0fmO4TfacZ2wFpUXkeambqgUYtYmqBRi1iVqXZtQmqhZg1CZ6v6hNm6h1aUZtomoBRm2i9IRRmxz1hFWbKKZg1CaKKRi1yVFPWLWJ8iFGbfI1J8azH6Leve/gAdL35O3njXnCNGCWV2GnPESZa65SDZkDxrEzhIlumKQdORDC1Gew58ljUP+c5HXqC/vgOacLUh7pBIrhmTIojJQYoYSdIp2UIxFgTgbJl2k9QVGDaYI6oAdlqxbzd0HcuL7zmqnO8KJ9GDmipORc47xBKmAabZPzlpQ22eX6xL5tiYntcmLg5Nn9Vnc3PaOOsm1nWFbGjdtBKCk1H0phwhFfeKPyGWfnKumDH3I7P1f90Nt952h5vh96Qbt/2J23W/r6h13Q7q+9HWMMfC6SSLdBPGOiuJlrQ77vjOrMX+pR8F6T/Le0vOZA7F4CzLBuzjWlTV716Dl9ClQvk1y5RQWQCMYv4HxD90Qw5uPYCVr8bO8dATt75iQAZSWPynUHi14TaNQ5qt5h1Dmq3mHUOWpNoFHnqHqHUefo/cg2nXPUJlado+odRp2jtIlR56h1tkado1iHUeco1mHUOUdtYtU5X3M7T+cc45k1Nv7wYxsrOV1ePLJieiotsW50LS9IFqfyznxiHiFNCAo9ZOd6jY4/J/sYZGuDWtcR2sKcTzL/1102lPPGH5ZMEDGKbxEnyJiZUw7uLa3X6od3jQ4mjoBVtM5ZhDRXX2scUncavJAYArN4ab0sS9ySbGUsyJ5tysKyBfoyCUu9ENrU+eRgmiTHtCQozMYfWeUEGLkIcaX4zWRtC4NhdcRSqQ1FPr9SzYmQcC/HOV9yPrn0wQ+/nZ/3fsTtvvO9PN+PuKDdP/LO2y19/SMvaPf/fDvqB+QFkZZgzCRco5w8HuUeEoqm25qALlRRS3pY1MxHySUnrck4X8l0bVU659WP2x9XWWRd5AZCt2W0xBYHaXUhNyZZXN2ZNb5GuWm0uYVgyaMQ4oKcubd2ta7DqpkUgzFqJlXTMWomVdMxaia1HtOomVRNx6iZlM4xaia1HtOomVRNx6iZlM4xaqajzrFqJsVgjJpJMRijZjrqHKtm0r7NppmOsdEaZ3/UsR/zjKurkZIPYysl8DUjKdGouTE0616ppMtNrmkD4myynG6iO/J0baZMb6jzo4mXq1u83HiHRPE7HKhVgkV3fMi+7SNQgAfpILxqmQ/H8MgiGIYtFfms7+eTn4XHLdTLMuUlgszA4Q4+mUGCeqtyAdYy+QlxWbaNl5oexsQm3MfrutVGYcp7OjxV9BUfy+D23TeXKohrVGJfzWNf1sCnRzmuTpbvLGsjDWyXnBEkffCjbufn0B99u2/tIM/3oy9o94+583ZLX/+YC9r9Y4/PCIadckaXFLAGwFOuJ02M59JioVKb90BGYiKSYAk8UhQmqa1OEgtRYL8dvl7zuP14EmHCWXaQDxAyD7LXXS5j2qSMvDOZaEejCZ4PpepNbBwtR2TBkrPSTFb9pTSTUX8pNmTUX6puZdRfqm5l1F9qLaxRf6m6lVF/6fMUbPpLrYU16i9VtzLqL6WZjPpLrXs36i/Fhoz6S7Eho/46aiar/lJ+0qi/jnHWGrN/3LGNAmjKPihvJcaO7ELcx6TEtcrKmRA9pIi4sNFxk5fQkvT6LE1eZwqbOs+KshflPcLHIjiqMgp7JLwGXwvzgUmSGLEoJjmhSo4zSfwb5TEprG1Mc70OGaG2j617OfSKubaksPgQvFwdMnYs97KQREBKJTNg9jiYp63MMWV50BqzZlaZ+EVLFiZIXeQYSgxTd124GNOZcc+T0LPMWdkYTZPRdq50Rlrp45KzgqUPftzt/Hz842/3rUPk+X78Be3+CXfebunrn3BBu/+X21GLEGzRBq0VQn2djGBCuSyqI/Lib0j5aAtmilyi+XChThJtkuMeJV+qPcSvffScZIWRFzmWDq5NfG5yfnidBIl9NkLXXgqeJc7ERCX+MSvzLlNrz0xvYrneQ2zTcqo2Z9RySn8ZtZxiVkYtp2pzRi2nanNGLXfUX1Ytp2pzRi2nz+uwaTm1Dtmo5VRtzqjllP4yarmj/rJqOcWsjFpOMSujljvqL6uW+7G387TcMWZb4/9PPLYRSRMz/nq6tG6gqunDsq/Ed99l8RJRhMok8echEMaNYoWU7BZqitPjyh/d41k2iBaNWVBZg7BIDWSU+rB1LATXS/Q+zJwK0YR6ITSNul9bE8Nv3YPWcnL3ELN1p2JCqGQGOxRZmZCw4SW0Eqt3+rIjOKm7dLidjKPmepMjvJWWo8dclTNWCTwr4zOh2TJhm1dLOuur3JDHvHYr76rWENacKctS4YS0Lcsl66ykD37i7fzc/pNu961p5Pl+0gXt/sl33m7p6598Qbt/yu2ot+RUBBRMGwSsyIQdciXYIDrL1SnOFZyaG6RRFF9BOaybJELmElmgdnXe9js9ek6ST0YNzjj3mrocviTpWTLRVkgVwcmlMAA7mlCax9EVCZYzIImmnJOq9pUbdaHeV27Thar+aNSF+k5Vmy5ULM2oC1X90agLVf3RqAvVGnCjLlT1R6Mu1OfB2HShWgNu1IWq/mjUhUrLGXWh2odi1IWKpRl1oWJpRl2oahZGXaj8t1EXHuO/NZf8VBW/HpbAo7mIAzGi66hFQrayK01O53O1yVXQecgLlCtIGYtVABg/MjunGZ9czbsshL3t4ege3gpDF+hG+bNkiqMrfcHHx8xrmESUMniPPjG8diZaUXsD5fZe8oArDOg9NB6EP0WoJfAvlGcJSTwCKDGKLJzroAM2OYS0V/5K1+vvUx50YU5hUEgd21zD6tuYJcgKnrA5GeMLjat5IfvARoCXJbTkW8j5mruDpQ9+6u18nfDTbvetj+T5ftoF7f7pd95u6euffkG7f8bxGROZB6uGzNhkHUHh7+4k45ocE7Ysi9zaTeSce+/8CWYmUX+UTHQkM2R/O3y986PnxB+houbCZ1MBSDB6ZEdfRTXJ+v11c0nSL3mcDIbEGIuELe9RiVg1n/S6NJvGVGcNGDWmPmvApjFVjdWoMZUuNGpMxfiMGlPVWI0aU9VYjRpTrb83akxVYzVqTH3ekE1jqvX3Ro2paqxGjal0oVFjHnWhVWMqxmfUmIrxGTXmURdaNeZPuZ2nMY+5xJqXfuZN154YginBF6kL9zboPrkUiKkk8i+ADCkxlbj1yA8cc92dJ94RBhBnPiuNOUgybln4bR8S8X1snjia5f06uZchtdSyy5G4kOsyhlymt3vEbAaCbOosakcoWGPpKYYJAqQ/GQQQTwY+UpM0IKdixPGw15QxDMZ0fFCEh8ZGOmxKY9atlx469WQHqUSpZqZ587Vu/EujOLJLhYRwvDNtPW0gkMgufaIjE+mS86ykD37m7XzN8bNu96215Pl+1gXt/tl33m7p6599Qbt/znEuC3iEva+uotMmyYuUEJKs4BthEJk3gjofNmDwIPVYMrOu7/wHv5JTuh2+3uXRc/q8yWW2Ecu57jxEJx9HNE6X25+ZW0OOs+2Ioy6Hwi0IDSZlyWUSYpng+kxLo17V6/hselWdP2HUq/r8CZteVXVko15VGtOoVxV7NOpVVUc26lVVRzbqVbX3wahXVR3ZqFf1eVY2var2Phj1qqojG/Wq0phGvXrUmFa9qtijUa8q9mjUq0eNadWrP+N2nl495iVrjvu5x35c4X/0i5xhQK2NRm5TLr3ciTPeryG1xitE0BEA6VdgSmHOln2RfRpz1eevbt5Nhvpc50NRHHnKvxIJ845O7XIl0tpp+pT9gwJpgJiRp5SbSxg1+kySlbkfZRetc5WARxh1QkHLgpiMxC7eH/OUMb/VbZVT3FGevBdAp9yhre4pc4U+Ls01OfQthJ2S/cacWr0j1PN2/EKS2t5yoSiMVOaNb5Npt3uSwkOIPl2/SB/83Nv5+uXn3e5bt8nz/bwL2v3z77zd0tc//4J2/6+Hz/KF7JYIJWtiiraHmwcm1YdCDs2TwsCcmM3A9ChLm8RjfjK6xxHCZ9t0rfx1j9tPLGzEdpKNrIZJJK4klxlK7qe6wNwiKtdIZG/bSsweFEfWhemF+NtTH/r8VZv2VUzUqH31ukeb9lVnkhi1rz6TxKZ9Va3cqH2VXjVqX8VEjdpX1cqN2lfVyo3aV+07MWpfVSs3al99XppN+6p9J0btq2rlRu2r9KpR+x71qlX7KiZq1L6KiRq1r6qvGbWv4ihG7XvMcdZ8+QvUZ4Vc/SYrPnvJNIY0yIgcTe4NmIE0KZto/Ohhh/qEUfdIYZ8hseXZoLyK1a55YdJlwiepbS2lDV5zoLsZHaVRo5QJQOt8JhnIATURTeyJO2TsFKrSvnJSmG8E4cB4Hz54GNPKjEdvEw32IkGdOMNALxLZiBZQV0YczdiBzerewBB5k2MfsorUM72R8JVv1ze5DIkZQ2qiZsrcmMw19HobleHKP7vcrSafcbYWkj74BbfztdAvvN23BpTn+4UXtPsX3Xm7pa9/0QXt/rrDZwWmBGE0+4T9RFkiDJiyTY6kWSoabVaKEXJBJiluLrJsm5lIEi5D1uXUcjt8vevj9pe9y0k3g5RICG9DDq2SExM2ie883mjM8DxRdrksciFYckwjKinUVhCnas+PUUfrs4JtOlqxWqOO1utEbTpanVNj1NH6nBqbjlbrAYw6Wmlfo45WrNaoo9V6AKOOVusBjDpa7fkx6mi1HsCoo/V5fDYdfdS+Vh2t1gMYdbTSvkYdfdS+Vh2tWK1RRytWa9TRR+1r1dGK7xh19DFfWnPvLz72Y53Di5qElzJ6Fic3XpfOJzIek1yZ2eiJthCZ9kBYJWMMB3FmAuTYN32P5w67ij2TroENrs2Fl750JxPHS8SRNC7rJMogKGXeBOM458lYIn2NqPZbESQaAYu00n1gWrrFr+gCulau9ZjMS6K0kyWwMUxoGUmu7Sh+Zm70YSodDdZuibGM5Jb0TwKnE9rwkGOJ0EsjGTN6NwngAPMRU4281kbgSb5ect6j9MEvvp2vq37Jec94iZ6U5/slF7T7l955u6Wvf+kF7f5lx7ncJaUSXAKJKkKO8aBy9gP2dkEYhVwicYqsVFrZROAgGXseshoJPTHX2+Hr3R49J4465lFRaqQ7gnzrC+qQuo6IRbkezEkiGhktTWHHk+nI5ZHQNcMqh4ApHW3U5Gq/lVGT63OtbZpcMWSjJtfram2aXJ1dZNTkSkcbNbla82DU5EpHGzW5YshGTa7WPBg1uVrzYNTkar+VUZOrNQ9GTa50tFGTq/1WRk2u1jwYNbnS0UZNrvbbGjW5YshGTa4YslGTH3W0VZN/3e08TX7MvdY8/suPz8V4nnTuIOg1uaVuk7c3wMmRcb1uDyuUo4RZIhkh0nlHlm2NN0NciV2t6xie7mVQMW6GnPFJ5K9Qcj6iMmBB3Tvt7XntADhHrCX4MlF5qZtrqGm11w3pzUTcCFzw9sGgIrTPhWHeB4GAWe9kxELoiDIBgT7WWAhCzcmpW5u6V9fvMPYFTE+WIaAy85lnROjVoUjCghJgTHW5/G/j03YCmctyFx7zMjNULtHk0ge//Ha+RvsV5z3jJdpUnu9XXNDuX3nn7Za+/pUXtPtX3Y7+eo+E4CErjxcSvlx619Hkfqt5uj3Nnc8QCYdY7ZNA6YJcqTvyTNSYtng7fL37o+ck8K6Ul5iOuHdUfEpjE52JzsroVrztTvyPlMRIUeueybiEADIaMVXUjlqHbNT3SpMb9b3a62bU9/oMdpu+V2zbqO/1OmSbvj9qcqu+1+dZ2fS9Wtdh1PdKkxv1vWLbRn2v1nUY9b1a12HU92qvm1Hfq3UdRn2vzxO16Xu1182o79W6DqO+V5rcqO+Pmtyq7xXbNup7xbaN+v6oya36/pfdztP3xzxu1QS/+vhcLWTGZZY8u8iSZ4ZBI3cEhDmDjp4AbzP6Uc9y3xEBrctqjzlS9649umNp2/JgaEbmW+0g9lQimYxpvSxu3erY3Qhy4FmuIZLDSZASB3doYKj0g95n2Ft1iQzN0FrQ3EzNWRIKhbmOzA9RTqDdeHu9RpI1ia0yfGGLdC3yRa3bJneSU8i0o8c5q2R3+tt7GjjXUBkocuhGIQ9sK4w9k894pi49NVPu8hln6z3pg199O1/v/ZrznvESnSvP92suaPevvfN2S1//2gva/b8d57Jo9b7scuHFFmUNGUGL2VIQdEhoQnFDKOytJ2QhWV6OPhM+PytlsqTPq3394/a/5eL5yf+QXg21UPaHcpjY7QwOkJvk85SdFs7v6F23VFIdVTa5TDvosyyMXkGt2zZ6BaXvjV5B7TM0egV9X4DNKyjmbvQKR31v9QrqjDOjV9BnnNm8glq7YvQKSt8bvYJi7kavoNauGL2CWrti9ApHfW/1CmrtitEr6PNqbV5B7TM0egW1dsXoFZS+N3qFo763egXF3I1eQTF3o1c46nurV/hVt/O8wlETWPXFr1NjYkFjx5X42lNaeGt5z7VuMg5pLzMmJodK7zFtndBF6Cyuk5iI2mB/p++dnyXwliWIeLInvSSH1SEqiMaS7xlDcpORXAYG4GdUQyfXSmhBl/PzVC2AcCyn5yHZFx6A+L7I2xqSZH2nt1rB0ES3A/HdsqJeGHykIEYv/ROiqgXkZV/3JgcwezkTttXIH2yDXC/JmoiMYAoSC0VoeTfG6hcfHWC1j7QN+YyztaP0wa+7na8df/15z3iJZpbn+/UXtPs33Hm7pa9/wwXt/t9vx3VoG3ahEj9JS3uR47w3pNVIJChJLwjkhBHOSPCdaVolkqH24ySboVqUV3iPR8/JxAlU9AoP6GsKBGbigQsV0NDH8KNX5HVosvllI/eEHnEqLoZErCBo67vFjL5DrXM3+g61zt3oO5RXMPoOtcfT6Dv03RY236FqAUbfode523yHOvfO6Dv0uXc236HW5xh9h/IKRt+hagFG36HW5xh9h1qfY/Qdao+n0Xeo9TlG36HPQ7b5DrXH0+g71Poco+9QXsHoO45eweo7VC3A6DtULcDoO45eweo7FD80+o6jvrBqld947Ed6hoqChE6G1VzixjuWoweLLF9YqTKkjfwx9t5Jk1mESs4B0d7JXKR45Tt40dsqS4/kwhMnx2LLWdl7I9BPCcqFWETQxSWkRFWho/6BpSRJolR06k49sj5veEp+qvyoxNsLIzuKGRIoikRUAs9SAhpn99kJnk0R2cAIxHzo/bVkgI5k4S/Qf0y3GkjgW5N7+cjCGBtkyS5aIvOAPDyJNpKMO+WT1PIld+pJH/zG2/k69Ded94yX6G95vt90Qbt/8523W/r6N1/Q7t9yUzqQeJEIfWhXgioaaSVi7Yt3RD1CX8Fq7yGLxvE7FGElu+78Hj+s1mW/Hb7e89FzeuR9Dcgv2XPuCcSxT+ZxIaGh/hBx5NgplxYRn9GypTL910SynWIe/KZqFEYPo9YgGT2M2hdg9DBqX4DRwyjfYfQwan+t0cOoGoXRw8zbeR5G7wuweRh1FqLRw+izEG0eRq1BMnoY5TuMHkbVKIwe5ug7rB5GrUEyehi1v9boYdQaJKOH0edt2zyM2l9r9DBqDZLRwyjfYfQwR99h9TCqRmH0MKpGYfQwR99h9TCKaxo9zFGrWHXPbz32IzM7UYDgEfiLGzGA7Fpkv3DLi6ywZuAyTiZxO3m3InvAsIXURoAlrHW9zioSP+U4PgLr4OUzGBNDIRGJfZKAS+pMdGKgu9EdW+CzSFuxMi1Wl1XtJEfeAT9vz84HURM7qmchV8oR8cRr4svSEraG1+jkbTJ8NkInvc1bU+dj+k30UI69ozZ2Alnc3RrnOpmKU17PXnsm0hPmGKiBCbnvcGf0yZ7X7Zp9FNIHv/V2vqb9bec94yVaXp7vt13Q7t9+5+2Wvv7tF7T7dxyfEXURyKQ7OgWRPfiXPchJQZH4neVmWARcEfvBaPcOLU8SIP3ujRphfjiu8L98vdfj9i/8KQqeIh/n1ueCEq9iYzJ+CMW0U6mBSWy7qGc5q8jJgWBBCqMN61P0nUE2P6RqJ0Y/pNZZGf2Q2kdh9ENqH4XRDykPY/RD++08P6TvDLL5IVU7MfohvY/C5ofU+ZhGP6TPx7T5IbXOyuiHlIcx+iFVOzH6IbXOyuiH1Dorox9Se5uNfkitszL6IX2eu80Pqb3NRj+k1lkZ/ZDyMEY/pM4VMfohVTsx+iFVOzH6oaOHsfqh33I7zw8ddY9VQ/3O43MVyjUkluaZM5VcigvCUKCjEBdEdzFFKCB+2LZkchyxgGGR6EMyoI9qLRm5s2Y5KYpQHZbmqpxtyiilKNQHI7iSDxifSJZESuoQaB60Fz8RBSsiTfkhPmMgwRiSRW4DyLyssqEJBgNV6kWJXExfM7swNuMhLZJBiQMoGfi18kMIEiarxL9VtrYHOTEyJzRIbgsZib/JD0OJBeQXYXkwDTfUFQOcVxcuWUsmffA7b+fr49913jNe4gvk+X7XBe3+3Xfebunr331Bu3/P8RlJmmuGaUgsDpP4TTxegBSkhqWRxNGjaZcrMgAaBM9c5A9MJIRzQAl11tMbHj0nQS8SIBaKtKNiQbJcFpd3tGQmWSbRTXMidwjJRTaArbKDa0M2UdwluXS1lszorfT9VjZvpWo6Rm+l1pIZvZXad2L0VmrfidFbKT9k9FZqX7nRW+n7rWzeStV0jN5K7zuxeSt1ZqrRW+kzU23eSq0lM3or5YeM3krVdIzeSq0lM3ortZbM6K3UvnKjt9L3cdu8lb4vwOat1L5yo7c6+iGrt1J+yOit1PkwRm+lajpGb6VqOkZvdfRDVm/1O27neaujhrLqsd97bCPBk0G+7ZNWDmIveRbngVyoKKAxCr2ZmATMG7yNYGk6s5Chgyyti/ocXcbnxqzpi5v0ci0ko0g7pczExCTluof+HWRd+Tc3NlnGlhpTdoS+qHN011xFw1RJrET9Khe9YaKQO5XXvM3JIxc5qZdIHhvVshCoNTGLpQwWlLciCTJPm3RMyg/xJ8r5XmvdJ3GTiSmNHOSTFfkkG3l4IVjLgFjpdesP+xfO1trSB7/3dr7W/n3nPeMlHkOe7/dd0O7ff+ftlr7+/Re0++uPz4gZYV6So5FEU2bt3taIg2BcM5FIY1HSRh6BnB9RSMOhc/A1SB1+ntqn896PntPLCb1kQaJhKORXKIUsWt33zeOT0jbRmuuWwRbI/rj5sJFksQ6oKnLOVHexWX2aWi9n9Gn6LjabT1O1JqNPU+vljD5N7dMx+rSjt7L6NOWtjD5N7ek3+jR9F5vNp6lak9Gn6X06Np+mztE1+jR9jq7Npx29ldWnKW9l9Gmq1mT0aWq9nNGnqfVyRp+m9vQbfZpaL2f0afo+CptPO3orq09T6+WMPk15K6NPO3orq09TtSajT1O1JqNP02tsbD7t99zO82lHPWbVdn/g2EbH6KWotJG2N/LFCKVLxy54tcWVFilgrWRwguzeO12INWqNKbrIfdWxqRrYWtu+ENSqW3tHNRGiS6CVvONAvsvE+WXNY5N7SxB3KdEZFLrIWWSbEb5M3/UXgy9hJYO1XCUMS+iJEoQICAujBLtIyOD15BYZ/5S5aMjSUItV35mNElwxXtS3iHXM1kZ0YPLWSVVvHS0yT9BIqJe2dhIMZTbmOUOGhDKke+Uzztbt0gd/4Ha+bv+D5z3jJX5Fnu8PXtDuP3Tn7Za+/kMXtPv/uB3ztNyNTf5GVfbEpMXX+C42gdwzSyXchJ3MS/AkLpLhqHsxmbyoT8KX8mnv8+g5KSHzxz3VcLk7BYVI0ipCeCiira2UUHwkbpDsCgGD6AvEGWgysu6KH1H3nVg9nzp7zej51JpAo+fT9wbaPJ+qgRk9n1oTaPR8R59m9XxqX5PR8ymfZvR86jwFo+fT9wbaPJ+qgRk9n97XZPN86mxlo+dTPs3o+dSaQKPnUz7N6PlUDczo+dSaQKPnU2sCjZ5Pnadg9HxqTaDR8ymfZvR86jwFo+dTawKNnk/5NKPnO/o0q+dTNTCj51M1MKPnU+uIjJ7v62/neb6jtrPqxD98bGMmrpPqVypea1wd7esMhhGRiI3CWEX4bHIF5h4L07oQlHLFL5VWHm5tV2dZBBFcSy3OMX2KX4kZ1PrIEUmUASMoEPzJdDnJkRi8KEYQfcy0Yrb2VXm+soc8ERkOWTHIs0SnyEAaEtO26DvmlKEmn5a8Jy2JuKKdhVmAVlFnWbi+bZVox0zJlZwzCQPbpApHAYMnw7hiIGdzktAlPtREXbGMhUHHJPaXrHuUPvjDt/M9wB857xkv8T7yfH/kgnb/0Ttvt/T1H72g3X/s8FlhZreToweqx6N5fWwRCOI7Kgu24qi/o5Z2ySMhYtLkkG0H4iHiyDVX7nb4et/H7ecZCHZof8QbTo3ATxrPBdcRJhYDDdR4piQn2Mg66jU4fj3i2PCBzC5VmzP6R7Xu0egf1Rl6Rv+o1j0a/aO+49LmH1Vtzugfj57P6h/VPjCjf1T7wIz+UXk+o39UZ1kY/aO+49LmH1Vtzugf9T4wm388ej6rf9Tnbdv8o1r3aPSPyvMZ/aOqzRn9o1r3aPSPat2j0T+qsyyM/vHrbuf5R32fjs0/qrMsjP5RrXs0+kfl+Yz+UZ27ZfSPqjZn9I+qNmf0j0fPZ/WPiucb/eNRJ1o15x8/PtdGHORBRt1I/FvjLxPVZ3KVeUxPya/xqqgwEGHJ4R2LSY8jxSgFtqrPYCfYJ6bsJmKuRWK0J2xmanJMc99qruSv2HZyE2OCud88wYfwvMuTh678o0OnFVQuZcMsZyHyz1SXBxGZeDqsp1zVypij3unDiATmjCJiBiGg103VDBdRUuSJGT0CEGnogt/zOhiemViQpVF74oUmKp2TwFgIRAwOJAdRv8lnnO0npA/++O18P/EnznvGS3yUPN+fuKDdf/LO2y19/ScvaPf/eZzLpcvJPEgI1A3ubRX3g/4oqHEkMimt7RgHJjDzG5u3dWbnLoegUknkf7fD1/s9ek68aUYpy7mJI5CNsEEAJ/Ly6kExvic5eYdg5teKRRn8rKWixtACOIte9BnsRi+qaoZGL6rWdhq9qDoL0ehF1dpOoxfV97HavKiqGRq9qFrbafSiat+c0YuqfXNGL6r8o9GLqnNEjF5U38dq86KqZmj0ol97O8+LqjPYjV5Un8Fu86JqbafRiyr/aPSiqmZo9KJqbafRi6q1nUYvevSPVi+q1nYavai+r8nmRdU5IkYvqtZ2Gr2o8o9GL3r0j1YvqmqGRi+qaoZGL3r0j1Yv+sdu53nRo+a06tc/dXwuOdM+MAXxpH5SsKQ7B3WPiQTgL0dmEJXDRPZlzFDJZPoOenFBcOw1bl2fy+8JhX7t6AUaEckjzOAk5UyERma+l+nlFtOVmUt8cCRKaixhYg5n2abyopUQh+30Q6LTPiWBh+xTFTvJtKflfpEhsdAloe1JIhJhujN0Js+m7w7eJoFXTqoJYy/LTocvnZbtQ3YXTrJP48MzytFjsz0eegSa0nCqxKpL1q9KH/yp2/ne5E+f94yXeDJ5vj99Qbv/zJ23W/r6z1zQ7j97fMYFdUg+zZMcgK0rhF6SPfnYYThgTQWvKCZjMt2jxGSPxFspd07q9yXfDl/v/7j9pP/ittmlxF8LkRqdnF1BzzOxeV7nEUpbCPysTOrEdeWa0LMSQogpqpZp9LVqn6HR16paptHXqvWrRl+rzrQ0+lq1ftXoa5UXNfpaVcs0+lq1ftXoa9U+Q6OvVfsMjb5WeVGjr1VnuBh9rb472OZrVS3T6Gv1PkObr1Xn8ht9rT6X3+Zr1fpVo69VXtToa1Ut0+hr1fpVo6/9utt5vlad4WL0tWr9qtHX6vvAbL5WneFi9LVq/arR1yovavS1Ry9q9bWqlmn0taqWafS1Ry9q9bWq/mH0tUf9atXCf+74XAGpVOviHSIoZdcL5lGKLomhPrclN7IZ0VgeiwFSM7oMG7w4kZDEXX1XgyuZbmPm0y0RFRA68mHiZvNEV9AtBIlBAsZAMkcDk/zhbFQSO+FRnU3q33KtNo1hMC7IJ/lgAsbWkZO73HlHGi9+5cOR1WtIBNqVOR2DvJKm92XmGoJrJRBLC+lg0Nr4sHKRWJtWuYl7bb0h31qoBMI9trYtnnorg36/Zo2u9MGfu53vc/78ec94ib+T5/vzF7T7L9x5u6Wv/8IF7f6Lx2ck8yGhUkTLbompS4zPDO/FrzGQ0VAjpAocEfXUDFJCkwaClkPn9B24dDt8fcCj5wzIbZREcsw9/gYmiufBMpDkSiKkebLXIhdRAshWEg+iV4wqDyqyL+uzSY0eWdVYjR5Z7cs0emRVYzV6ZLVG1+iR1dmkRo989LVWj6zvubZ5ZFVjNXpktUbX6JHVvkyjR1b7Mo0eWflao0dW5+cYPbKqsRo9sqqxGj2y3pdp88jqrgajR9Z3Ndg8slqja/TIytcaPbKqsRo98tHXWj2yWqNr9Mjq/ByjR1ZrdI0eWd83Z/PI6vwco0dWa3SNHln5WqNHPvpaq0dWNVajR1Y1VqNHPvpaq0f+s7fzPPJRC1t19V9Sc5uAI0t+B1PHh4YOKXjginTtZOYu+YZ/Irt7pQmOpx8I7o2x1plhXtV+Gc1OUuCatvQgu+qg3MQo3etGy4j9CKmG82ykEITzJofQVvqZtFYWp+7vWMmATCzSx86bciL5+4Ygr2iBIbtW/YhbrWSWSL/h1/HUiZkiR+PyOtX9HTulrcTbjqvsnR1ExCp3eaz8cqBARl7CxFdUR3ByCaPMj7RUQlctYIIin3G2Z5I++Eu38z3TXz7vGS/xivJ8f/mCdv+VO2+39PVfuaDdf1U9414RTngavLIXaUlAQcehG1Y5MzlOP8UyN4LpgkxkzCdZgp+I/Eyg5Xb4+sBHz+mxrXjiIMswMN17H8ztfSMvb3ItYkroH2QPAZGfTvkZQzK37SGjiKdwqvZr9Nuq9mv026r2a/Tbah+r0W+r2q/Rb6t1yEa/ffTIVr+t1iEb/ba+k93mt1Xt1+i31Tpko99W+1iNflvtYzX6beWRjX776JGtflvfyW7z26r2a/Tbeh+rzW+r+zuMflvf32Hz22odstFvK49s9Nuq9mv022odstFvq3XIRr+tzi4y+m21Dtnot/V9hja/rc4uMvpttQ7Z6LeVRzb67aNHtvptVfs1+m1V+zX6bbV20ei3/+LtPL991NVWjf7Xjm3sIp6jCMc9UGgOVI/bZDTKzl+MK7EI0Yn2ZQwO6V26wjuKzAgsarhV+e0lp8arXnxbln3m0rDrlaBB+l9oykbQJQHFlXjF2JBn98SLIPKs0PlHvy2yPaK4Gekk1O6ZzREUUHhNfU1p2chwgQI5yXClUr2KckG7LKL0kVbab6PYeFIiGBHPb/JQI1LNpql7Rbrtu1iRbac3E4Meiekj/RpC2ivD8GEN6tn+S/rgr93O919//bxnvMR3yvP99Qva/TfuvN3S13/jgnb/zeMzoiRResRhVALBm5y2FXKkx3kOORSbiREy3CzHNAnCTKXuuqxCCeLCy+3w9UGP20+amjJ3fS8L2pncCEhbs2/RSWoTlR4L7AuURRMcDnCNcvNsI2rjT9VZwUbvrmrSRu+uatJG765q0kbvrvb9Gr27qkkbvfvRb1u9uzor2Ojd1Vpro3dXftvo3VVN2ujd1Vpro3dX+36N3l3t+zV6d+W3jd5dnRtl9O6qJm307qombfTuet+vzburO12M3l3f6WLz7mqttdG7K79t9O6qJm307mqttdG7q7XWRu+uzo0yene11tro3fV9mTbvrs6NMnr3o9+2enflt43eXZ0vavTuqiZt9O6qJm307mp9ptG7/9Xbed79qNGtev9vHds4kWguh0xqk6lH3BeTzmBltEZ+mSm2JDIsWgtPHvn9nRlFMp8pbkiao0cWVZiIB8skkCZMwVIHAp8nyOhyJ6c8+00eCDUbYlmCHCG0FwbGKn9F1co3JihaKEYCKArFjS3gA9Imgo6OiWUVp+DQ0IzNHAk1Cz96ItkJTzWp9eQM+x1xvATsB9KGsMKf7JucZuQDSYRJM0PwC482xIBkhC0BAZEix1yv8hlneznpg791O9/L/e3znvESDyvP97cvaPffufN2S1//nQva/XdvRw0eE4pftDbJBzmI7ht4N4+JxbWXvO/E+xFGX8TqUkqPZNzZ173KLFX3/Hzw4/ajSF3fyHdRrkVGmWbmJWkZN0yoJaPJQfAkodTJjK4NvuFrWMtWiRuqVm7lAOrMZyMHULVyIwdQtXIjB1C1ciMHUPukjRxA1cqNHECtJzdyAHXms5EDqPXkRg6gvLuRA6hauZEDqPXkRg6g9kkbOcDRu1s5gPLuRg6gzuwycgBVKzdyAFUrN3IAvU/axgHUPT9GDqDv+bFxgKN3t3IA5d2NHEDVyo0cQK0nN3IAtZ7cyAHUmV1GDqDWkxs5gL6P1cYBjt7dygHUenIjB1De3cgBjt7dygFUrdzIAVSt3MgB1BpUIwf4m7fzOMBR71u9w9879iMpnlfuialbZpLz/H5f156mRIyQ5d4lLxV52oQxp3EjLD2Rk+l7T9pTfhsJR/Vf7m2iZi/CIiGqA6qANC+nlaHwPC5CxPvYkCobqQ45QIIkaCRVww+9bYN4TMBlxsgi4LxVyv8Ir8Jgp7MWuQk4iUpHPI8cSA5bzwMVlGNR56X5wfRhfPKVEZCrdwQIdA0/oiFiUVA8H0Qg+LAWWR1AVEGqkJsikVik7+m+UPrg793O94V//7xnvMQPy/P9/Qva/Q/uvN3S1//ggnb/w8NnYUxJhTX20mKQ5fA5k7oIUbiOIQvl60LQ3irJeqLx4H1U8AfJbQQgW1J3P33Io+f0OHEku6yGWXvD6gXiBfFsY840Ev1a97bhSSELifCOBMDgNLx77XnH4ep95TamoNbMG5mCOrvbyBRUDd/IFFQN38gUVA3fyBSOHMDKFFQN38gU1Jp5I1NQZ3cbmYJaM29kCooDGJmCquEbmYJaM29kCkcOYGUKal+5kSkoDmBkCuq8NCNTUDV8I1NQNXwjU9D7ym1MQd39ZGQKigMYmYJaM29kCooDGJmCquEbmYJaM29kCmrNvJEpqPPSjExBrZk3MgXFAYxMQZ2XZmQKas28kSkoDmBkCkcOYGUKqoZvZAqqhm9kCmqdrZEpqLqfkSkcvYPVh/wj1UZZVl8LfURbmfmI+XUn66DnaqsIoOIISlOOaWYIVznUbVSJwgxC4ovaF+BqRN7xjYefogIG/UoMlljmBQcQ3oekVR6CmYVpZ9BBLjy2gc5VZ9WFSDLv8obocP5qkZXMKOeI//E7A30Vn+GJqWHyHhA6qS6oscDIJyiotQVEckQJnVXEYyF6XQqkfMb/QPDsCeGDvpP1FXRwmUuOyCWGrGwVoGvlM872mNIH/+h2vsf8x+c94yXeWp7vH1/Q7n9y5+2Wvv4nF7T7nx6fsW8pYsDJTA7JL6McNFgJrgxt5A6zZ0u7JFbc8vaQp/fFpUpC5+/oM9g/9NFzBlycELsm0ZXPI/MHHpVJXsIUPjgqHiluaLIsxz2SFVsJmPMmNyAkdVadlU/offg2PqH2BRj5hDqD3cgn1NoCI59QawuMfEKtLTDyCbUP38gn1NoCI59Q+wKMfEKdwW7kE2pfgJFPKKZg5BNqbYGRTxyZgpVPqH34Rj6h9uEb+YRiCkY+oc6qM/IJtbbAyCfU2gIjn9D78G184sgUrHxC3wdm4xNqX4CRTyimYOQTam2BkU+ofQFGPqH2BRj5hDqrzsgnvv52Hp/Q90nb+IQ6q87IJ9S+ACOfUEzByCeOTMHKJ9TaAiOfUGsLjHziyBSsfELVI4184uhDrJ7mnx2fCyvQnFza1kkNqyNrjwWVxstKlXkykKRyXn0txHgUNcE6kyJaov2VJKn2PvRKPJhl86g978hvi6S5DcdQiBPL5AX0SOivKCq6iDEio3tspBtSlb4jzq1EWznSn+hOdq15i8TGIrfAIdjcLMSRgAeasqHB814Jv05CECJx9+nRmofEOyKiJLmMfQ09kF6JhLvMcUbXjmvZ0CYoKzexCcQ4BEXgtRfJL/IZZ/tV6YN/djvfr/7z857xEp8uz/fPL2j3v7jzdktf/4sL2v0vb0eGMJnHo+Gh1y110ZeLIzeS51c+lTBNnRlV60myhCzElBtMMicngKzM2dvh68MePWcgsWzkGObIQEEGFElffCXainjFRmGGcSW1EWOJ3zvPjYmXAzeZuD5XdU6gkXWovQ9G1qHPLbCxDrX3wcg61Fn6Rtah1jwYWYda82BkHWrNg5F1qHMLjKxDrXkwsg6198HIOtRZ+kbWofY+GFmH4hNG1qHWPBhZh9r7YGQd6twCI+tQ5xYYWYfiE0bWoc4JNLIOtebByDrUmgcj6/i623msQ90RZ2Qd+o44G+tQex+MrEPxCSPrUGsejKxD7X0wsg6198HIOo58wso61N4HI+vQ95XbWIc6J9DIOtTeByPrUHzCyDqOfMLKOtSaByPrUGsejKzjyCesrOOf3s5jHUdPY/VH33DsxwW/k3vJKcvCcBxPJ5v4sYjIW7aEBiFHoIFkpcP0O3GEMCTHIdLrNOfRnQglhOkI74N5iwqg62os/Jvs4NjxQYi63ojS9CNvfBchxRQKDf1SvTrnoRF+EVRlIFQLLoSXnPEJcAkmdQ9y+xl6CdFDxq5I9UQoK8xuvEde86LWYvBucT3o1UhG5pNkUzsDIlSiVljkTvDEx2Co1hw8/qDLFRF0UnHE1/xwn9rZ3lf64Btu53vfbzzvGS/x/PJ833hBu//Vnbdb+vpfXdDubzo+4+IL4T8STaesPloqEzjgpRecZ/NhhLx0fmshFbY4MUVgyE0yLFKchHI7fH34857TIcWJoREtKhgyLsiG1JEnC7kJBUEKwo9XMACeCsOAsOhyTQkhsTq1v8PKTdQZjUZuovZ3GLmJPufBxk3U/g4jN1F3Ihi5iVqLYeQmai2GkZuotRhGbqLOeTByE7UWw8hN1P4OIzdRdyIYuYna32HkJop1GLmJWoth5CZqf4eRm6hzHozcRJ3zYOQminUYuYk6o9HITdRaDCM3UWsxjNxEn/Ng4ybq3kAjN9H3Btq4idrfYeQminUYuYlai2HkJmp/h5GbfP3tPG6izmg0chO1v8PITRTrMHITdUajkZuo/R1GbqJYh5GbHFmHlZuotRhGbqLWYhi5iVoTbuQm//J2Hjc5+iOr1/pmNb7Ic8icRU6gJNmQSxOIhOhHB9OgwNhNi+Sd3HOt22x0OdK28dQBUanWiIjqrIGI6ch/DMHqHNN3xSMwcouXMzKJNgReaXaU6xyxY5gJiMy67OpcDI9aQTGHviSCfRPF3kV2uYrU3JC9It0Kuqb6dfN5wDsm2YwEQ1Bj1Ko1IpFeJx46h5RLpDA+JffUqIxX+o4GezfFTCUeLOdCr1QEWJOTQyOCTT7jbB8tffDNt/N99Lec94yX8AN5vm+5oN3/+s7bLX39ry9o9/91+Cw5bUbOnllEdS/CKwm1UMIg+1VwVHL0TV1QxMzBldwEByXwNuIpApgpfjt8uee1H9HI3A6jrEgQ4nCR43LaZJrCFslLWOUum+Aa+hIPvMqWs0rYx0WNMT/9dh6DUdzEyGDU+ZhGBqP2sBgZjD4Xw8Zg1B4WI4M5chMrg1FrRIwMRq0RMTIYtUbEyGDUuRhGBqPWiBgZjNrDYmQw6m4LI4P52tt5DEZxEyODUWtEjAxG7WExMhh1LoaRwahzMYwMRnETI4NR52MaGYxaI2JkMGqNiJHB6HMxbAxG3SVpZDD6Lkkbg1F7WIwMRnETI4NRa0SMDObITawMRu1hMTIYdT6mkcGoPSxGBqO4iZHBqPMxjQxG7WExMhjFTYwM5shNrAxGrRExMhi1RsTIYI7cxMpgvul2HoM5ei2rb/s3akzIi67YMeagiAg59qNjDzApC3ExSYSvqDA0XCw9EQF5ZCcpCI2A+j5yk9TR2IQIRs3g0R3PLiLXYat21AzKkiTLfBYagpnD/RE90awIytBD1Pt0RMxt+wQBkTPaTkZOWKnCT0d0LfS/GJgF3ZK2NlELjH9sRcMJCOdRDCYgEDqBYUtoP/4w6qRjXFD0Ox9KOsqi7Adjh8yy44mY1y6jm5jx7uEK+9M9ufTBv7md78n/7XnPeAmLkOf7txe0+9/debulr//dBe3+9zfl1R9u4SHFJo+ZIlRBNsmzhPO99mUViIApk+OGcaAwD5LEeAipHfOg7hf1j9uPnMdfMolQ5HLgqWNyrlU4B1KAlNPIjSQJAnhGSNEIwvaCxEBqozyGOpvUyHPeeDuP5ygGY+Q56mxSI89R+3SMPEefI2LjOUcGY+U56o4SI89Ra1eMPEetXTHyHLV2xchz1DkiRp6j1q4YeY7ap2PkOUcGY+U5ap+OkecoBmPkOWrtipHnqH06Rp6jzhEx8hx1joiR5ygGY+Q5RwZj5Tlq7YqR56i1K0aeo88RsfEcdb+okefo+0VtPEft0zHyHMVgjDxHrV0x8hy1T8fIc9Q+HSPPUWeTGnmO2qdj5DmKwRh5jjqb1Mhz1D4dI89RDMbIc44Mxspz1NoVI89Ra1eMPEet7TfyHFXvNvKco2+zesD/cOzHlURE2ORDKtM/5JZlCxKOAWnooSnMeETQ5OHq2F3HCiS0zwhivJA6+q4Z1FDFX5HOePcM0i0sREI8BIJwYRg43g9pk9ahVhM/gByL0EF3Tr9rngN3oS2MJtQtopm5EmV3hWxtcn5OUdB4RQRAWonk/Asixy05ygkue+yK59DHO6OHIbou61xFTBDvcB1dRj1vco1r7kjBRtfsWC46JaOm+MyNJstnnO3vpQ/+w+18f/8fz3vGS7iGPN9/vKDd/+nO2y19/Z8uaPf/ffgshDsZb2DCSKOelP1w+qs4E0lVgYFPQmsi4JEMjhm44Gr2mjcwKMZX3TkbHrefpwxrqaL+0Ed4K7wWJHVgEtEliGiEdaUFqIxKCIkb2YEPniKEAbyK5xjZkDoX1siG3nQ7jw0pnmNkQ+pcWCMbUnuRjGxI8RwjG1J7kYxsSN01Y2RDak2NkQ2pNTVGNqTW1BjZkDp3xciG1JoaIxs68hwrG1J3zRjZkNqLZGRDiucY2ZBaU2NkQ2ovkpENqXNXjGxInbtiZEOK5xjZkDoX1siG1JoaIxtSa2qMbEifu2JjQ+rOWSMb0nfO2tiQ2otkZEOK5xjZkFpTY2RDai+SkQ2pvUhGNqTOhTWyIbUXyciGFM8xsiF1LqyRDR15jpUNKZ5jZENHnmNlQ2pNjZENqTU1RjZ05DlWNvTvb+exoaMHtPrJ/6z6kVkYUXS8j0Gq9KK/MwO3ZhTGuqaCUcOQBCfZE1+BwXS8zUziwvLo/VbBbWtmJhcJmBiFHJlQEQk/4kSRkGIZu2QW/s0RDrtk8IyIWWvFRKlzarCO646J4+9tKaWVxN3WTByTZUKCiZAghY6h44h8YV9crfu+4nwfQqG+M0iyqfQc81ksKU9FhFr94gMjibjtpuSQKTm2ihvi2ZEYxBYCCS9ZPuNsViB98J9v57OC2zP3zUgePvCZ89v9zJ23+6GvL2j3i47jPKBEIgoU+Yb7JCUg33ErSEAUYsUZVEkezI99hNJXZLrrpCV0FM4tt9vhKz5u/4LeezBRO8YXSrttvortJJUj3xaCGb9D0kBdMJUWAvQkjqEjgQVuRMWGjJxJsSEjZ1Jn8ho505tv53EmxYaMnEmdyWvkTEc2ZOVM+pwaG2dS+62MnEndGWTkTGqtj5EzqbU+Rs6k1voYOZM6p8bImY5syMqZ1H4rI2dSdwYZOZPab2XkTIoNGTmTWutj5Exqv5WRM6lzaoyc6ciGrJxJsSEjZ1Jn8ho5k1rrY+RMaq2PkTPpc2psnEndQ2zkTPoeYhtnOrIhK2dSbMjImdRaHyNnUvutjJxJ7bcyciZ1Jq+RM6n9VkbOpNiQkTMd2ZCVM6n9VkbOpNiQkTOpe0aMnEmt9TFyJrXWx8iZ1B4NI2dS6wOMnOnoJ63e9MVHb+ra0oitszAz0SONITEIO4jx3pHTGAnmathEZUZxNox6/hyeMq3o2qo401JCbcg3TG3phKcuUagLwaI/e4rEBdKhGI0oJy7nxrhGQC3bTl/29ciZHMgn5A1ryxveljRp0cYsJNr3hbFQUJu7k+xF4zyTBtuIpZUlUkE0nuJMvgfJfxMGJfpTBBqtI9+jc9YOHatij+migWbHC8DTEJEdK4Lezkk+42zuIH3w4gu4w0vunLfI873kgna/1Z23W/r6rS5o90uP45x8xx/uC+6aBIascigJiW9u3VvsQxYDShIn1K0r0mGp+CmsDJbUZ82ZlkfPGYKYHNhux6HhPFYX5QxyfGzgYaInIcl20mWFdxCvfcGCL2izBbmRSHGaM9mYleJMRmalOJORWanzkI3M6gtv5zErxZmMzOrImazMSu0pMzIrfa6PjVmpPWVGZqXufjIyK7UGycis1BokI7NSa5CMzOrImazMSq1BMjIrtafMyKzU3U9GZqX2lBmZleJMRmal1iAZmZXaU2ZkVkfOZGVW6lwfI7NSnMnIrNR5yEZmpdYgGZmVWoNkZFb6XB8bs1J3UxuZleJMRmal9pQZmZXiTEZmpdYgGZmV2lNmZFZqT5mRWanzkI3MSu0pMzIrxZmMzEqdh2xkVmpPmZFZKc5kZFZHzmRlVmoNkpFZqTVIRmZ15ExWZvWiZ85jVi89kVm9tTqnGZHDA5NXto23XyPTfzCJ9jiZ9nt2CQmxB9kER/JACeJ2maKNwVp5g+oOryThgVFOuMfgJAY41CczPxzBpaCI61iz7NcpachgT/u+450c+teTaRSzaht5P/FiEWLrKloGOZj2yqvtuWfGLXOIxJRXmeWzkDj3DQEbKkFuK0dm5RvPSjBGFDJliORL28FwmbdescuIBgd961PGOfm/EztwbeQYZGvG1slnnM0wpA/e+gKG8TZ3zm7k+d7mgna/7M7bLX39sgva/exxnPc0kAyDoQ0QmNUJVUoLDhQNncgMDe0eYLEbqHbKNeZOtpum3ckCxvTc8dMPX+nRczKxER0LmluSKA4wxU0AVe5FRAAUh5kHBMJR5CQ+Z5NkR2KSc+xBaOoOLyP/0szKxr8UszLyL8WsjPxLnUVt5F9fejuPfylmZeRf6ixqI/9S++aM/Eufg2TjX2rfnJF/qTu8jPxLrY0y8i+1NsrIv47Mysq/1DlIRv6l1kYZ+ZfaN2fkX+oOLyP/UvvmjPxLMSsj/1Jro4z868isrPxLnYNk5F/qHCQj/1LMysi/1FnURv6l1kYZ+ZdaG2XkX/ocJBv/OjIrK//S95Xb+JfaN2fkX4pZGfmXWhtl5F9q35yRf6l9c0b+pc6iNvKvv3s7j38pZmXkX+osaiP/UvvmjPxLMSsj/zoyKyv/UmujjPxLrY0y8q8js7Lyr5eeyL+ePZF/vfz4XJIHZUlWzqgRH/EBMq7C9Ix2QnVdOgQMGyoKBdOwMPIH0giJg/IYmn8tDHGycG4YMmAYSUxglK8MfOIP3px0gZjGcSMyERBEWzfRVSRASX2KfxGOJ/pgrRXxVJk5LS3eMYdX/v/qeI2JB5hyqRTDFX+K0iHy8CfXSEfqc8B5VymGRsh1PeGrdiJZxXXwYlamgxyAxUsoCN2EuSmE1UrKRgFE5uPD+chn8xDpg5dfwEPe9s45kDzf217Q7re783ZLX7/dBe1+xbHdQxYadggNlIFpjJAH8q6ks4K5kI25YJs6Zk0IRuTrhhho6753x5yCCd8OX/nRc/JDg6gPZhqSYyzIb7d4IhlBeidW7MK/ZCGkmC3yEfotFPwIv95EfSv+ZWRp6i42I0vT/MvG0hT/MrI0xb+MLE2dA25kafvtPJam+JeRpalzwI0sTe0NNLI0fW6UjaWpvYFGlqbuYjOyNLVmy8jSvvZ2HktTa7aMLE2dG2VkaWrNlpGlqb2BRpam7mIzsjS1N9DI0hT/MrK0I/+ysjS1N9DI0tS5UUaWps6NMrI0xb+MLE2dA25kaWrNlpGlqTVbRpb29bfzWJq6w97I0vQd9jaWpvYGGlma4l9GlqbWbBlZmtobaGRpam+gkaUd+ZeVpam9gUaWpviXkaWpc8CNLE3tDTSyNMW/jCztyL+sLE2t2TKyNLVmy8jSXnoiS3v2RJb2ihNZ2tsf24jWJv/TnIrYWRbhVgNWFVC/OIXmEuaGcRykTUvl9TvXGEjkgCljQq8li4ynCstCCQS0XmWSr+A3MB2/RcbnzW8NQDZXRAvcqwdywSCNbnJI1pGloX1bYb7ghvmQkRH3LvPHO1lzI0DSIaTQvQfEDYKbTwKLodqTl0Pkhz5na3QEfsJKVAkyPIzbXWfAJk/gLp0JFgmLQg4jnYvqR/zta0ae4NTDw/ViZ7MV6YO3v4CtvMOdMyV5vne4oN3veOftlr5+xwva/cpjjBFnFzAIGIht3TbyBaadNI9+RgPmKVMdB4kIATmJkZVj6SBRGzOjO7WWbH30nMistommxz0J3BpxACNQpX1BGuCFBz59QF1WkgxTaIPlBcloZEDysj+yNCuXUyzNyOXUnXpGLqdZmo3LKZZm5HKKpRm53H47j8vN23lcTrE0I5dTZ7AbuZza/2jkcvqcLRuXU/sfjVxO3aln5HJHlmblcmotmZHLqbVkRi6nztkycjm1lszI5dT+RyOXU3fqGbmc2v9o5HKKpRm5nFpLZuRyav+jkcupc7aMXE6ds2XkcoqlGbmcOoPdyOXUWjIjlzuyNCuX0+ds2bjckaVZuZxiaUYup/Y/GrmcYmlGLqfWkhm5nNr/aORyf/d2HpdTZ7AbuZza/2jkcoqlGbmcOoPdyOXU/kcjl1MszcjljizNyuXUWjIjl3vpiVzu2RO53CtO5HKvPJHLvUrtC3Mrf5zmeSyb0Ck5AaxJXCYxo5AYLb767JCaiAzeQ2M8eHCdpPig70bc94pc4EWgaHkScotnuhPQeF3ErVF3V2QuYQxQLYvs0GTEbngoJNSyqTVueJbQCUX8GKSTkLNBNM7rTpAsvEGR5biEiizHg+NbIrGy72TR1PFZao8nngyLQWbeFjnqjOHIkCVOt9rpfnoeudMd82EMwAaukRnFT2gDr8h7lc84m9NIH7zqAk7z6jvnU/J8r76g3a+583ZLX7/mgna/9thuZAG5GZGOmG1i9ceW/I5BzDvSZBMIsRCRmSxbhH1UWfwJLBCchkjyt8NXefScDyzt4WhBck4XMbmA3sXEblgMstkmdI/AkSdccMcdZI9pWz04DZ2T1Bo3I+N74+08xqe4nJHxqbsRjYxPczkb41Nczsj4FJczMj51/r2R8X3F7TzGp7ickfGp8++NjE/t8TQyPn0umY3xqT2eRsZ35HJWxqfWuBkZn1rjZmR8ao2bkfGpc8mMjE+tcTMyPrXH08j41N2IRsb3dbfzGJ/ickbGp9a4GRmf2uNpZHzqXDIj41PnkhkZn+JyRsanzr83Mr4jl7MyPrXGzcj49LlkNsZ35HJWxqe4nJHxqT2eRsanuJyR8ak1bkbGd+RyVsan9ngaGZ86/97I+NQeTyPjU1zOyPjU+fdGxqf2eBoZn+JyRsan7lMzMr6Xnsj4nj2R8b3iRMb3yhMZ32tPZHzvpM4rxxHj+BbZybomunWMFUhWJJ0suNidnE5vQP0W0gxjhczsG7MU4ZHmptbeER/dTgbkSchHeG0iO69o9+jUFUdGEma6bikVMCAeAJ2I70GZQxLJBOqOS2bMVpE58DiQnkNzENhF2JMEZE55ubgAffEQ1JgQ6Fl+WHfQjEDsVGvvdqI26iBh5AoNhGtM/D/RH5+/LOIZeVkN7SpMJCZR+vISeakTKljlM85mPtIH73QB83nnO2dd8nzvfEG73+XO2y19/S4XtPt1x3FO8JPVr2sJMO2VPBb8zuf2hIMVKdk24A5KpmIWUKhytBtZDXOFx17Kc1jv4Wt79Jzw9khGxYwtMRY5/tBJ1gjbwxUejiciSiKv8bSkeCY7k5/IOQU64s235629M/BCtfbOyAvfdDuPFyrGZ+SF6o5LIy/UjM/GCxXjM/JCxfiMvFDdPWDkhV95O48XKsZn5IXq7gEjL1T7WI28UJ/jZuOFX3s7jxeqOy6NvFCtvTPyQrX2zsgL1do7Iy9U57gZeaFae2fkhWofq5EXHhmflReqfaxGXqgYn5EXqrV3Rl6o9rEaeaE6x83IC9U5bkZeqBifkRceGZ+VF6q1d0ZeqNbeGXmhPsfNxguPjM/KCxXjM/JCtY/VyAsV4zPywiPjs/JCtY/VyAvVPlYjL1R3Dxh5odrHauSFivEZeaG6e8DIC9U+ViMvVIzPyAtfeiIvfPZEXviKE3nhK0/kha89kRe+7kRe+K7HNmLoloFS85WJ6yMBuqc85L6HbaJa204mBg8g5x6UexVtHiCIuM4sTkTt+w0J+VJ4owRrjHt/MHlMrQqiwNbyuFCM0fHhJUSCHNGZYF5TYVAsUa0J3KakGObgQB3TAphh7lPuQUU8I1uxwg/baVfmI0Y6ijIk0qFcs6R2xQvF8YECMfsLBGVvsgpSvExEFQVUbKebnWh8/H3DBGGX1tiRVwwmfls+42x+JH3wrhfwo3e7c24mz/duF7T73e+83dLX735Bu1+veCF0fpDEdsIyEbk6RyEAB01MHaIE9yERbZA7mHAI50RQyoAIXAf5Y9wOXx/x6DnDtritCr8hMTdslEsPCXbm0TEEQVYUe36AMDRZa7jjAGAdpFBHEg9Orwm0scfnrQk0sEe1JtDIHt98O489Kl5oZI/qrlIje9S80MYeFS80skfFC43sUd37YGSPX3U7jz0qXmhkj+reByN7VHt1jexR8UIje1R7dY3sUd1VamSPak2gkT2qNYFG9qjWBBrZozr3zsge1ZpAI3s88kIre1R3lRrZo9qra2SPihca2aNaE2hkj2qvrpE9qnPvjOxRnXtnZI+KFxrZo7r3wcge1ZpAI3tUawKN7FGfe2djj0deaGWPihca2aPaq2tkj4oXGtmjWhNoZI9qr66RPaq9ukb2qO59MLJHtVfXyB4VLzSyR3Xvg5E9qr26Rvb40hPZ47MnssdXnMgeX3kie3ztiezxdSeyx9efyB7f4/hcExeam+zFpcNL4d1JeMV30plOXGgkEzGvcUiyQRhvkZNHxi+O6YhEVhyTP7SLIqGBBc27l7EgXAetWAoBCnWKzNoACRjTjiRAhkYGMhYAtzMUe8T2o5bGLjTBoY4JoLANuWvDu33HFGGMSepoQkyHqA/pgCg3DnTZS/zl+t2TJBodz1+RTc4430IKxwytcRLHaNRSH7qS3NEJPNDOhicktBKmxW6fzqKkD97jAhb1nnfO4OT53vOCdr/Xnbdb+vq9Lmj3G47jfDwwEHIN8V2UdehNhCVmlrDFfB5ogB28FwWsk1BC5Y/AAWTnMh7odvj6yMftr1noPy6GebvJQZpxWVEEae8Fu4G1xvzJFHLELQyT6xWgOOX/C+ubij0aOaZeq2jjmM9bq2jgmGqtopFjfuHtPI6p2KORYx7Zo5VjavZo45iKPRo5pmKPRo6p7twwcsyvvp3HMRV7NHJMdeeGkWMe2aOVY+pzAm0cU+1HNnJMdeeskWOqtYpGjqnWKho5plqraOSY6pxAI8c8skcrx1T7kY0cU905a+SYaj+ykWMq9mjkmGqtopFjqv3IRo6pzgk0cswje7RyTMUejRxT3blh5JhqraKRY6q1ikaOqc8JtHHMI3u0ckzFHo0c88gerRxTsUcjx1RrFY0cU+1HNnJMtR/ZyDHVnRtGjqn2Ixs5pmKPRo6p7twwcsyXnsgxnz2RY77iRI75yhM55mtP5JivO5Fjvv5EjvmGEznmex/bOHkbqDL4H3F6IZqAADyTCV3eOhgPA+DgEPQinkGUMb9ZYiAWYDCmvju4t9WhVPkDdNC611xFpnpPnJpyjiLB2MlGbk+wIkamnZwb4CK0vCyLU/edxF4qXpR40pl0E+ey+FLESvFNqiEuSi6YkgraBKyIXEBGieBADyiOSRAmDAaxJz4szKJcaQykAQGNYCLQYBwJiAyOiDLHZw1C7iBeInO2S9ZQSh+89wVc633unOfJ873PBe1+3ztvt/T1+17Q7vd7RvlFKTt0HO+GHCQ3Q/qJ8VkGvANcoo3kMNMN4rdH6A+mBbM2kXvYIj9vh6+PevScnvRKChxQjAY4LEhRJAyAj7lIRBT+0lzyyHbMCNmJ0IhgE4IJfIIQHDmmlYkqjmlkonoNpY2JPm8NpYGJqjWURib6pbfzmKjimEYmqu4ONjJRzTFtTFRxTCMTVRzTyETVfSdGJvoDbucxUcUxjUz0a2/nMVG159rIRPW5ijYmqvZcG5moujvYyETVGkojE1VrKI1MVK2hNDLRI8e0MlG1htLIRNWeayMTVXcHG5mo2nNtZKKKYxqZqFpDaWSias+1kYkeOaaViapzFY1MVHFMIxNV950YmahaQ2lkomoNpZGJ6nMVbUz0yDGtTFRxTCMTVXuujUxUcUwjE1VrKI1MVO25NjJRtefayETVfSdGJqr2XBuZqOKYRib60hOZ6LMnMtFXnMhEX3kiE33tiUz0dScy0defyETfcCITfb8Tmej7H5+LCUhSh1ssK4qZid0CLfWLe9h4vcedCCJn2a07Opi3MeWlbCMsxCPSrbprhu5ri6RA5Oq6rJiwBckcsQa4SsQqQYuARofUjXcnjHTHgpJDSDRMFnUOpWBZkCt/McmBekwdRNNeAoYuEnLnhJh6nB8vHfIwtgRBYZpNPABzux2ZKPle4hZhE7MXRQFiexBXWMDADyYaTsAGBn5D/kfkcV8LYnkQzrt4CPmMsxmZ9MH7X8DIPuDO2aA83wdc0O4PvPN2S19/4AXt/qDj/FvyEAcR0cQEWmE3qaOVSWII9+iizD1CNsm0IM4Ttt9hPgr20cv1M7fD10c/es4wgtBL3Dm+ChsfauNvUePAQsS+LBM7hCsARQVZKk7ClKXcBDa8L/pPMVErXz0yUStfVUzUyFf12k4bX33e2k4DX1VrO418db+dx1cVEzXyVXUHtJGvaiZq46uKiRr5qmKiRr6q7pox8tWvuZ3HVxUTNfJVddeMka+qfeVGvqrPobTxVbWv3MhX1R3QRr6q1nYa+apa22nkq0cmauWr6hxKI19VazuNfFXtKzfyVXUHtJGvqn3lRr6qmKiRr6q1nUa+emSiVr6qzqE08lV1DqWRryomauSr6q4ZI19VazuNfFWt7TTyVX0OpY2vHpmola8qJmrkq2pfuZGvKiZq5KtqbaeRr6p95Ua+qvaVG/mqumvGyFfVvnIjX33piXz12RP56itO5KuvPJGvvvZEvvq6E/nq60/kq284ka++34l89YNO5KsffOxHhEwgmDLGF7Fn9AWpVM79iwnzuWM90GMrQAClPuSTGamgVuRXnrWrNacBnIEE9ES3mLOk454rcQzSAMv0CFnSYhNgggoCUYBVxkL2C0z5zeep+OrgHbZ9QUJDctA6hAg+ZJPbSuC7iF6k1taxi0UCBTqGMVsAowhHiM+uz+1cwLBdYrRfZACFDmLF0JMesSsME4R9AeNu8jrJRY4PQxe6PjfEYpPPOJu3SR988AW87UPunDPK833IBe3+0JPb/dzXY87o5SxX14IkROwMj0eGQ/4guzsqYQE44j0SfhYxRgqp/Bv5dRJGUFRF32ntH06R7SIaY41JQhwhdO1JiNKClpcQvfR12SWZYuqJ9tQ7CGP84dbU2ssUwZFgDbKgGF9EKVIVwINVQGs5WY4aHiDJhlHf5YKsjqLOI8DX0AJqD3lYSPIPshR+yByA7QTqEHLWLq2WC7IkPBXeBD45ynwjVKNbiZcLrubIGcFXUD+gJ7p/Fe4lx+vymczBSUkHP4Z/hyKtS2rIVpwz3p9PwhHiz7peeylnb3Scf8apY4V3fOnAkRREC+apouTF0ZKk4RsEXMJ6lIkf5KyM1S/qvhuyQ1rWgHPdpQgEzR0C4TL0rJPJiMikqkZkxhUktH5OZEeEHISj4dgVZxQSSdJb+BvgXjEBCEw0EGYfOUHwwdvLdel4K7nzrDJIAB8YyNxhrFNxRkRRl8ISGgG6mAhwZAps2T7RuVgvPnvimyAliXEChgMe8NiIM+l1zRnRhfgOkCa6mvzqVgdAXBGGBeKDfiz8FyG6b9gXlH7fNvJZAyNXT/5U991QcGN074wyBKeHrgP/IrwqMkrQUpXUTXjmNcOK1rRQqWroffGMgSxX9J3WK7SjgsF4bQGAllBCCTXPsF69k4NleYkr423CiXZ4wELGJE+ifhMdvag7rUlPaCYn+QWXuRAuwKuFKSNpBzldXd4QYwQKRnClouAFkIu37xI+FGdkzCPhGTA51EVMBOSo0QVMQ3iQHBgTkN3F8eiMWMoYkorIdOhW/mzU992QQcifDK+NyYL2WSOPMugunCW4kIImAh/XIC1wJDLm4TKoJkpJz+u1l1BE/CuhAb2HF+DtwhRFLBUJR4NGwWQrXgDptNN6OpLfipmBJ1NLrb0ElvLq3SqvKhXYmw8CJoA3C9GjUXdgRi79gXgh7LEdOAImNj2fgV167SXJFN2MmmQGiA+ThexwLnTLXrOMF4IbngC1kIRGghf7RMyT9gfVWbWHHHCaxVk6pAMOCaTahJHLKSC0JuEypH8d012GvCjzljzBsqH1Y1drL2mccCvM9UY/YgOJKssg9TPsGLad/6EE+FU5vGdS4oWbkF5WOUWHMRc1Z6T+gxCAge+CxRGO+BQpWj3UOygjBdkYg/LAu6Qo5oEBT+DJ8NctR8UZC7CWHCbOAW7tUNcM+QnmYlAyFpim8EdQp5C0MVsLgsidzHmZmOr8SnocHUwxhHQjB6vDVVHqgwiGypJKNJob8YRERmGib+gTCNoucxRLPNSd1rQg0SZefaLitQF7kaRETVTyKvWuBicG08v5zwV1XTGx4EHgGXYe0633kAOkXAo4b+IzNr2KjeAP+oKtltIEWL4iCtHyaLaaqFwFwjd1eXgtqVStvRSKjeeUCyHJscxfZsYQxbfKjOSdkayFvNBYigNUEBmxiFQwAQ57RLWHHEO60i38sRLeMpV6ZMBmXmwVEboScfDxvWEoqDOtBEbyEUFf0OgMijNSeQC/rjIHnSQaMn9t5BymfNsLQ6wVCADqMpGzVw/zIBHB8OHwm2tZrb30G2oWfQt4Ir4tcAYIJxJVKpbkeLQP8Za8EaNodAFi0F56RIp3YDHFGeF3kOnSFmIfYYf/CJPiV8EfQ7iJMrscVw+5gelvsnRhJQsxqudDwnPq/MoheISYQonGyZlaEc5Psa3yVwupDT9Ql4WkwIieVNQYiEkWUQgPpWCh116WCfyjzEt5TlyxJ9NDXBgDdXvYkYY5pPH4DKpP2cn8ouaKfRSuRp1Wrb1EKqGQ+GmDckSSQQ2xGpTvCF84r5V8CweXjoW0EoIwqlh2piU8GkGlzq8kDuziAnvYW5HoHNcH4kUcncxjnCH1wzCJ8/QapIy5VOR5eRUoJKf2kFNoFqcCfIapkKY2CXv9YWnKxDHhTJhgA8CDKIM6U4fBiDJVCV8eQqU5YyswD2oWHQTnqDAy1oAjAMWdgIwXWuSaVQ8wn4wpogY0i+JzKRRKQAWKM8ZMvhPcULaA78SlEuEpPNJkhICEe1yUkx2FnhmFySI/4p35ryJ3FqjzK+G2C3SLaniXh4MU18q0pLpReAwqfYRmAhyJW/iKF6fIFzG3wuX1+ZWMCVAFncy4JOrIOh5mEakeOhuIL6BVxCEjlDBCtsRSMl1xAZRVyDJF3XfDnwfVTFInNp8ysZRgB9qJIDsqIoSB5oQZysSm6oG0TlPcbBchNPJQnFHqUv6h6Mcgjw+2PfIeeEZe/xA4h1Wn4gVxYVijEgFfCRTND5Y1O+pOa8mFEKMq4DPJ+BYVnyjKbZAxCpD02JB8sWJIpxSpIYJyOB1zm6A91H03vI0kkZTOB4QxMIlyRIBBrE2oPwY5UBpa5SlluY5iJaLw7olyVCbjqtZeAh+Bv/SJK1JBot7fMfMgUFFbzAoCECyNFMyEqQLkinh9xCrwjnGvOCOGxEGRUYzYE/ELVLlIhNAbpgyqmwnv8OyAd8pv1NVJeqvoqMofQV6ptZcwMyGZHQ4iLJ+cAH7YhX4jpIhdTCAEKw4LsYsrlLr0msBDdDO4Ue0hx9YjGgV3J6o7cjafq1Ip7ZAjVARkMAeBhHAupFur6EOAQJQ1WmD5Zer7bhboOikRVk9KpMPk/xHBAGnMG5leOwNK4gyVCrFziDiaCaAFA+1dcUbUn9SLV9eBZlB+HpGXvMpGWEwvdQWUK1Sd1yZ1IUcnChnn7a+JUJHUHvKduUxOpvq0rRtzHAbPg0HEE+ZTFopRSZaicxaCKc4ybQ+AB55XoSaKM1IpAnbivANazaG3i1TkgXvQkJbkNogHVMWDZym7ZuAl2Yg4hwNjTqk95ElWxjBV5PkouEHtyYPMkUWwPTOeAVUHMgxJSblvlfIlw1qUDyowZcUZBzAPe4OnAxh1pDDuC7dFdgDhTcGMVBCoi/ucqT4LwpI6HJVfYgYpQt2Di0pIWEQqQQ6ZtBCBmLRwPXq0SzQFp8uxjmDHhWgh5FOCY6HYRt08VLX2MjPsiRFiPXm6JKQTOcb8wMmQX/kNkC+zk2TZEETUY7PMHiQIMXMNR85IqVVqnSgOHg9x8oDfqKLiQqh3MNeRQMRrrA2pUVaGeMl2/EaWZY5R7zuV4o2Ygg5HEasCKqPDeO+4aWg85VckbifO0J2MVX7mJn4Zh0KOWv2ZnPHDjs+Fn8DoMB9Q26ID6liQKuJGiFVyHmd4gAjo4o0xSPLNWFAK5WQkOndRe9udIGfiPAVjPolsw6yiloTIJ3RR+uLN89ZgfAuhlGLiSmGb+ctMh7m2rDijOByPk6A6jwgWxsL7lo3pBBkq/sBQrBAVvSljDfIuxTQJv1QakBtRcUYnwpSf5qkJOerppCqMMEXp8XA1CvmJ1E+W4DPp8o1YnxsBtcuCuOIvWccpffBhF/C2D79zzijP9+EXtNv9D+KMjvGIgiE3UQ7zsvoBIUoa9MAJTMYiB14uyJrSUFjEhwnfLrIoMWJzUEtqPSMSMS2ytmlHNDCqpxw+K5f3kE7RN61jqGGaghgfjApzS1wVtpoyohtvVO8PQ9dl3zqArk7mK8oUkYqrw1jIWkiEB7xNztFF6kq4B+SjDR40XFLrGb2cW0FdTAw/SQdul2QRyoPqZ3ZQeJtoGtFYlDuF7T9UAZcysRBUGoLa441uwR5RLy3SoxR9MED8zZ0COhETJxxlsRNlrET5m5y48H90dpCC1erUvdroXl7JBPfAdtAEGEAcBrCyDtIHkzbSAVLEK7x/Ui2FUBpHdiF89eSC4owJiILEIt+jwGUVa22iaaNkY+KI3MJOl+EccQFRSB6IYeW5V/AfVfJdfdYs/Jkgxbmxy+KhFYHdsMOS0YOY6wxsA8hNxK3U8aSQUZDzYDTinDqrMmRMxg4qoHTLKwWA7FKbRplQ4tmlrDulbudlrcMiNBp3xZhdIxIHbKw4I/k4ilGW4hr2jfkji1N58XgY5F+UI4mFWxdRv5RhoIs8MUOM1ORj1JyRxkCt+4ZEgNhQ+mJwSepbPUABBUMtKcsF9Qj+LGvpZd0sLASxi5t0R85IvQ4aKet4l0TrkdC7VPAZcaTjHIeIXbgCLoa6aa6CEVDUVKdl2SNeRnFGqDtFZgYQ2R4KvZDQUKg8IiYiSmF3ESGYoURBFvOQA6jCdqwqrItqpDqrkrdIPqGkH72sASoCrKhm8WtBdiIsjYrkIjkGv7ZSMCRpoeREHsmmBcUZJVehWGA15KwFVe06+RJWg0aIFBsRICjQKIsl4duBCiRuSNbq0gd4RsUZKT7TLPBVBm3RPqDSTh8Bx5cV6QX6jF4K3kwZ5E0l9Yo8kcVYEESeWO/xbgxFeiZPsP8qdTVMLB2BBcIWhgTxQIO6yh9CnVLjR7TKkkwoHxOqKc74sCMC2+2wZXAadCllB0RDLF6KsnQaQGlDV8tchUx7KdZTJJA1hUNzRvwdvt49kDLczS4rH0T3CvjJEM9GjKWWIqAGc7BLIRb9ucmK0iAradUe7yBKAF0OGGOQbbIGnAIEgztLsXIyLZJQUeSzeDYpsQogxGUxg5GNijMWscHYAAgLtREmmlugBBEIyLjHMS2yHiXL+KD3iL/A1yAul7osvjz8HDXud+oKyKjchCDJgltxKLvn1eAqAlCQSVbEISKacVE8EyiE+oSTgaPOqgyiJWUJiZjBAQKmUu3ldOYYSB0YZZyhrK4H5sOrJhED97TjAwlhBeF55IwOnYYdkN00BGoCIvUk2BL5rHrAjdzKCG+kRvtgfDYB+UilKjq/y7noaj0jrIA6MlKxE54g/ZTT8Tg4CpIYKYXMiWAuAlBgI6h1LxkUJA4D4bGS5owdMMp0kykn/DljTrYgzAUfVnmAKiuFsLmJObbu8rxS65GVohkmovZ4A8NEwdIsYDc5jAKUk3Qly29RozJuBd/JGUpiJBlalFbwlxWbS8RQZ1USg3fgCYmAN8GLI1nKSVC4aLgz5Xp8JjE+YPCZAFhFdG9+mApUd3gZR84YZEALOeGlyJYijFnEvqGBRuSzOh0ra6uIpAwL3BFSeRcLBEkkpPis7tUepIVFvLPIDanHgUhIF6unesY474B2ZnqjPsrwH4w4ypypRmEBvDjFGR1GVWCnfxAC4ERc+i6nRlE9xfVIIUBQLjgEyo65pW7QpGyUGWzQmeXrVfxaUST8BbJXEK3ewL1S6mDuUrlkamOjQ8YP42gbJU6qfrLrilBNnslFcUaqsVG2lY0gJTushayfI9eS3OQwLaxt4oFW5gbmXZKCk40tdJFcNbAHtcebCC9nbTHvRYF1kuwmPrXLNgtYY4OQUWwigvBnIK2eiP2wtB3S3nD2+l5tcJhMC/zkTolTljpl0GOWtU2LMAJZskEtVkpN5ILawNjEcYCTeBh9r7aTwgcjasFhy3unt5AhKyXHIXSe6ULIKLIGAnmJDPYVxQm9D1A6GLnijFhLXphUMqhmT1QT3B88LvUV/iKYW5atgRjQKwRG2UexyA0NWHiG4DbUHm9q010EWkiivGE2gFycI2ZwElRwdMhSwnuVTTUiUISWgSMZXVKucGqPN8pY/C0SJAwUPZVFqXGivxA7cDx+DOOUsYCGlpqsCKYiTAy1B3hPijPysogLQg6DRFbSWWQUwCQ34D/xGHbBK5BrI5h/lMZHxORWpi6On0/7h+q58J0AvSlTmQINQxlfzK+KMCTRgHPIQ5vQqUowZTQSOVB4Qdaswu/UHu81yeIrUToAoC3JVgm0mJPlOrSC1yULBpvUcehhOpE36R7WykKF05bUesYGXmbWvSWVgrxloS51N7TEJF9Qi2GuUCeNUgSX5YlSTiW9kAHAQNui1jPCIbEVyyq37cp1uTnIWjxQKEKNETzAr1TvH/gGIY4yPqob8c7oz4SPqs6qjBJCUeSQFegpyYEf6iT+oCRlVdEKSZDMMmQM4l12WdjbqSF2yR6KMzIIVvxDQxLuggWSVGpIIrKmlQwCUVsoyeWcZERTSZJVUfSFiLzIu9DrGb2gz1WGPbp+b1KsI2BSfAOp8j/mHRmVALMRYgH0srYUSUcOJdnALl+kzwxrfAxECZrB7EYGyN3BjU8W95apNgaiwpAF5CsJC96E8OLvPCyLbkGvZ8QzYhWkdkbdkZoMzyOrrWn0IjtAkuzFY05RkkhZlrfz8iZ/nnJFpLFqPWMilxHgAoCIymQTTM2EKUtIVbaoymqXRk1Usg9hjTy7y+DGEroMNOmKM3o+gLiMIwUEUYgjHW6yWUnE+SJ8a5es2kSPVLhxkPUvYo4IcbjIojgjzabxPPhg0vK7pO4mSycKlc+N3LgD1ICCBH0wI6JQlorLdKeWxptV92pLVZI/tRI+dmBNd1n2I4LC0W7AX9A0ZgtISayFUvEjePWJ9wTDxAAkvcdbVgWQEevDslvsFYM1+AX70h7WCIo7Y040MTCizmAQXbivLD+IcymKM0rRG29GwJSSjY9SPCZnRvAqRb4FBjVxM05Yn2j+ivEg3Eq9mPDi1B5v6LkEdJw9XQ08JHzS/yJAAiFWNBLRmUnN9HL0LPPyyUKQjmZY9qDWMxL6KMY20ZbwV4Y8Zn1kWYlSnOyfowupZDL0EnU5/AavYJEdeMgLAsV6Jmf0xznEcxBOZK+ASEqpxTO9RVWu4E9kOGFskcXAqUid/GGBFtVvqbaRP8hPx88KslscubzKqlQqrtRKIYuy3FOstqxzgdbi24JsCIXwbbJDkjnF68LjJHWGJsXnh6niH5Zp4Rb5YbG3HDdBg8gLAoZ7KMBtFBBxjnCPPmQJPZi2+S/XcQLEL8gAFi+7pRhbgzbJmgBZqMRcpGqKYyGEiRnig8l/sQtOIr5s8hln8zbpA38Bbwt3zhnl+cIF7Y4Xt9u6HlnWrn7oBe3+5y+5uN2yVxoMT+luk6q+rLunsaKziA+yhsMvMpHhOFRzZMU9AhrDTBFgQxs81DTcBe3+Fxe3G9UkC4nQ49T8EWCyFQUH0oRvoB07AgJTQ7Wa2nOQxTCb7F/dV1Ir7g6YywfGC9r9L09u93NfLzn5OZfz5qM/cYz7E8eNP/YF6gSJmLE8ZLwqG1azbPMdIv0ZKACgNcrCKCy6l+q6rBZGTCA7Ze+MK08bg8725aUPlgvGYLrzHCPPly5od37mhTH3VqX5KfBG4rWDlcqxyqBxrBqFDKrL+ArZ5FH4zhDF2kTWyS6+Ir8IB1mjmnuyIzzLCT+y63wXB4SOG6ioxQvakX2SmMwH1kl5DWO/yrpzVDJMFjB6nHsYBCw2dAjVi5vkj4LSwQGy4CKufkMEY2tkCz6kGAa04SfhHLMTbsuyJBUHAWb8HCBOqPy4XXYxQU29UFeKY7KRcpOzkDKivUJKg2xHnYItCd3+mjEofbBeMAbLnc89eb5yQbu3F8jc+wjlrag/iH/CvFAuKbJsMsn+YjmDYJmABpiXrNQqRTaJBORjgHPIbhk5lEfPPVmIAUeEGsGoSCNNqiYAPi/3qS6gXxEkOGjBnZDqPcpu3SJL1EOFTB/nHg6HWp6DDoDT+IlwgCnTBG5JUQV2RpUhkLaa1LyLbPXu25YHqk+2z4eg8l4GAUC/IKKO8mKoE4DZ+zplcaRsNJWlpZRoBq+CckDe28DOCxtN0JZwyRiUPviIC8bgR9753JPn+8gL2v1Rd+6tROPkC9r9DXfurSS/bBe0+xvv3FvJ3P6oC9r9r14g3uqjT/RWJ45xf+K48aovZn04bwLQJ3UFippymM0DHCS7ym48qpebrMVITfY0Mqm2jqTdoJkUgS+JtdIHH33BGPyYO88x8nwfc0G7P/YFou8+7kRv9Q0neqtvPNFbHeee32SPIsVWt8tGqEgJdg+UjajZPCy87pEk1kZJUjenjSVBQJJsG9mT7L69Ygw+9MEFY/Dj73zuyfN9/AXt/oQXyNz7xBO91Tec6K2+8URvpeYePKPLgWPrssYk5VbK+IW32GUFB1BjymLBzZPwKCGupQ0v9TfZg1Qz9d0rxqD0wSdeMAY/6c7nnjzfJ13Q7k++c28lGudjL2j3N925t5L88gkXtPub79xbydz+5Ava/S0vEG/1KSd6qxPHuD9x3HjVF3O4Olfy1Vg25v0INclSLALCxnvzcu6unKMy995DrA/r88hUEkSi7GR82hh0ti8vffApF4zBT73zHCPP96kXtPvbvUD03aed6K2+6URv9c0neqvj3AteNndTId7b2sm7TtQiPzA4OQd5GaHX9HAm1jbIUnyEnP9RV9kIvyF4wxVjUPrg0y4Yg59+53NPnu/TL2j3t3+BzL3PONFbfdOJ3uqbT/RWx7nHtErQwg2h5DqPs1Q5r0lOzJYbvv0u2wb3IGuUY5MjsSdt5QfJ8QAh+XxJ3pM++IwLxuBn3vnck+f7zAva/caT2/3iR89n9VaicY652epZJG4f443VC8hYfOMF/fLe540d91wcfNHt+V9nj9NnbtfE8pvtOf3jXzi+i8968hI++5knL+TFT/4pv/F7Hv3aZx8Gz3NfL7Y93PMe9pn/7wPJPRpI/rOeOW9QfvYz5w7K59737dsYlNbn/qxv5bn/ez/7+Lyf88yFDywf/qJvY2D99/6czznRub/pxIF11Tt80zPfdoT77/05b7pYKZwxSd/0/2LsfFtfjz/3zP7+Die+w2Nwls/9+NvTM53lXTz+eu7zzs6en/3M/T/jd7zIrT1vwJ4RVO6x0f8j5dj73C7qLNtzfqty7HOfvIQ3P5Zjn/sUOfbm/wFy7PgSrXLsc0+Mom9+gcqxz71Ijn3eMxc+8OddIMc+70Q59vl3LsfkHX7+BXLs8+9cjr35SbvPlmNn9vcXXCTHvuAgx54WWM7st6f1nbN9+Tc/c//P+IVXybErH/SMAPXc1x3Bl+c95/uc+Flf9P9Ttne2L/9FJweX576++JkLH/iLnzn/c7/k4gztbF8P7f6Swxs+6XPVZD3b473vRf3jjF/yGp/zee99aP8zT97Bi5/8/lvx/VK+35rvt+H7ZXw/y/fL+X5bvt+O71fw/fZ8vwPf78j3K/l+Fd+v5vs1fL+W73fi+535fhe+X8f3u/L9bny/O9+v5/s9+H5Pvt+L7zfc/mvQlGeTIPW+t+d/PddXb/Pkny978s9nD2158XnvPzz3+S+/5vPdWz+ljc8e/v3l/432v+Qpf++Z/8Z/v+jRP7+1P/utBd+3e8rvPfeZr3ryz+PzPteOlz3652sOn3viu/TPff6rr/n8p/bVaw7//upH7Ty+74876Rme+7zn5spb3Z7/9aJHv/fcn308Z545//n842d58VN+1nNfz42ZVx9+7bn3+f8AXxvAMCOMAwA=","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"// Circuit for validating when shepherd checks if a sheep is the wolf\n// Verifies:\n// 1. The sheep is alive\n// 2. Whether the sheep is the wolf or not\n// Outputs isWolf as 1 if the sheep is the wolf, 0 otherwise\n\nuse std::hash::poseidon;\n\n// Main function for the shepherd_kill_sheep circuit\nfn main(\n    // Private inputs (only for the wolf)\n    wolf_value: Field, // 5\n    wolf_index: Field,  // Which sheep is the wolf\n    wolf_salt: Field,         // Secret salt for the commitment\n    sheep_positions: [Field; 16],\n    sheep_alive: [bool; 16],  // Alive status of each sheep\n    \n    // Public inputs\n    wolf_commitment: pub Field, // Commitment hash as private input\n    sheep_to_check_index: pub Field, // Which sheep to check\n    is_wolf_result: pub Field  // Result: 1 if sheep is wolf, 0 if not\n) {\n    // Verify that the wolf commitment is valid\n    assert(poseidon::bn254::hash_2([wolf_value, wolf_salt]) == wolf_commitment);\n\n    // Verify that the wolf is in the correct position\n    assert(sheep_positions[wolf_index as u64] == wolf_value);\n    \n    // 2. Verify the sheep to check is alive\n    assert(sheep_alive[sheep_to_check_index as u64]);\n    \n    // 3. Determine if the sheep is the wolf and verify it matches the public input\n    let is_wolf = if wolf_index == sheep_to_check_index { 1 } else { 0 };\n    assert(is_wolf == is_wolf_result);\n}\n","path":"/Users/damianalejandropinones/Documents/temp/noir/scaffold-garaga/circuit/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}