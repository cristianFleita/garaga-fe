{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":16350508884478996391,"abi":{"parameters":[{"name":"wolf_index","type":{"kind":"field"},"visibility":"private"},{"name":"wolf_salt","type":{"kind":"field"},"visibility":"private"},{"name":"sheep_alive","type":{"kind":"array","length":16,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"wolf_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"sheep_to_check_index","type":{"kind":"field"},"visibility":"public"},{"name":"is_wolf_result","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"// Circuit for validating when shepherd checks if a sheep is the wolf\n// Verifies:\n// 1. The sheep is alive\n// 2. Whether the sheep is the wolf or not\n// Outputs isWolf as 1 if the sheep is the wolf, 0 otherwise\n\nuse std::hash::poseidon;\n\n// Main function for the shepherd_kill_sheep circuit\nfn main(\n    // Private inputs (only for the wolf)\n    wolf_index: Field,  // Which sheep is the wolf\n    wolf_salt: Field,         // Secret salt for the commitment\n    sheep_alive: [bool; 16],  // Alive status of each sheep\n    \n    // Public inputs\n    wolf_commitment: pub Field, // Commitment hash as private input\n    sheep_to_check_index: pub Field, // Which sheep to check\n    is_wolf_result: pub Field  // Result: 1 if sheep is wolf, 0 if not\n) {\n    // 1. Verify the wolf commitment is valid\n    let computed_commitment = poseidon::bn254::hash_2([wolf_index, wolf_salt]);\n    assert(computed_commitment == wolf_commitment);\n    \n    // 2. Verify the sheep to check is alive\n    assert(sheep_alive[sheep_to_check_index as u64]);\n    \n    // 3. Determine if the sheep is the wolf and verify it matches the public input\n    let is_wolf = if wolf_index == sheep_to_check_index { 1 } else { 0 };\n    assert(is_wolf == is_wolf_result);\n}\n","path":"/Users/damianalejandropinones/Documents/temp/noir/scaffold-garaga/circuit/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}